<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[WEB移动端开发]]></title>
      <url>%2F2017%2F05%2F01%2FWEB%E7%A7%BB%E5%8A%A8%E7%AB%AF%E5%BC%80%E5%8F%91%2F</url>
      <content type="text"><![CDATA[详细讲解了移动端开发的各种问题以及方法，通过学习本文章就学会了移动端开发。 个人笔记，仅供参考。 常用meta设置 viewport 视口(可视区窗口) &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width,user-scalable=no,initial-scale=.5,minimum-scale=.5,maximum-scale=1&quot;&gt; 默认不设置viewport一般可视区宽度在移动端是980 width 可视区的宽度 (number||device-width) 设备本身宽度 user-scalable 是否允许用户缩放 (yes||no) iOS10无效 (我们放在事件章节解决) initial-scale 初始缩放比例 minimum-scale 最小缩放比例 maximum-scale 最大缩放比例 devicePixelRatio 像素比 n = window.devicePixelRatio 像素比把一个像素 放大至 N个像素去显示 X5内核可以禁止横屏浏览，比如QQ，UC QQ强制横屏或者竖屏显示 &lt;meta name=&quot;x5-orientation&quot; content=&quot;portrait|landscape&quot; /&gt; QQ设置全屏 设置之后会隐藏掉头部信息和地址栏，底部的菜单栏。类似于PC端F11 &lt;meta name=&quot;x5-fullscreen&quot; content=&quot;true&quot; /&gt; UC强制横屏或者竖屏显示 &lt;meta name=&quot;screen-orientation&quot; content=&quot;portrait&quot;&gt; UC全屏显示 &lt;meta name=&quot;full-screen&quot; content=&quot;yes&quot;&gt; 禁止识别电话号码和邮箱号码 &lt;meta name=&quot;format-detection&quot; content=&quot;telephone=no, email=no&quot; /&gt; 可以手动添加识别 &lt;p&gt;13888888888&lt;/p&gt; //禁止识别之后，这堆数字就无法点击弹出通话按钮 &lt;a href=&quot;tel:18888888888&quot;&gt;请拨打电话18888888888&lt;/a&gt; //可以通过手动来设置实现识别功能 &lt;a href=&quot;mailto:motao@motao.com&quot;&gt;请发送邮件&lt;/a&gt; 默认样式等问题 在移动端中，有一些默认样式不够美观，我们希望清除或者修改它 清楚点击阴影 比如a,input,button这些标签点击会有阴影出现,可以通过-webkit-tap-highlight-color修改 a,input,button { -webkit-tap-highlight-color:rgba(0,0,0,0); } 清楚按钮圆角 在移动端，用border-raduis: 0;清除圆角是没效果的，一定要用webkit-appearance: none;来清除。 webkit-appearance: none;清除之后还是会有一点圆角，这个时候再结合border-radius:0;来实现完全清除。 input,button { -webkit-appearance: none; border-radius: 0;} 默认字体设置 在PC端我们一般会设置宋体或者微软雅黑这两种系统自带的默认字体。 移动端，默认字体只有一个英文字体Helvetica。 body { font-family: Helvetica; } 选中文字设置 避免移动端长按选中文字 body { -webkit-user-select: none; } 但是这段代码的兼容性不好，目前测试在IOS下有效果，但是安卓下面会失效。还有比如长按文字弹出底部菜单，这些的解决办法我们会在事件章节中详细解说。 选中文字缩放 为了避免用户修改我们的文字大小，需要用-webkit-text-size-adjust禁止掉。 body * { -webkit-text-size-adjust: 100%; } Font Boosting问题 在一段文字我们没有给它设置高度的时候，在webkit内核下，文字的大小被浏览器放大了。这种问题不是每次都出现，但是有时候还是会出现，这就是Font Boosting问题。 解决办法： 设置高度，如果是需要用户来编辑，那么我们可以先设置一个最大高度。 设置最大高度 max-height Fixed定位的问题 移动端在以前的系统版本里是不支持固定定位的，目前来说已经开始慢慢支持了，但是支持的不是很好，具体解决办法需要放到事件章节里解决。这里我们列出一个不用JS解决的办法，但是支持也不是很完美，权作参考。 &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width,user-scalable=no&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style type=&quot;text/css&quot;&gt; html { height: 100%; overflow: hidden; //隐藏掉html的滚动条 position: relative; //增加一个相对定位，方便给header做基准 } body { height: 100%; margin: 0; overflow: auto; //这里又会出现一个body上的滚动条 } header { position: absolute; //基于html的绝对定位 width: 100%; height: 40px; background: rgba(0, 0, 0, .5); color: #fff; } section { padding-top: 40px; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;header&gt;我是一个头部&lt;/header&gt; &lt;section&gt; 页面内容&lt;br/&gt; 页面内容&lt;br/&gt; 页面内容&lt;br/&gt; 页面内容&lt;br/&gt; 页面内容&lt;br/&gt; 页面内容&lt;br/&gt; 页面内容&lt;br/&gt; 页面内容&lt;br/&gt; 页面内容&lt;br/&gt; 页面内容&lt;br/&gt; 页面内容&lt;br/&gt; 页面内容&lt;br/&gt; 页面内容&lt;br/&gt; 页面内容&lt;br/&gt; 页面内容&lt;br/&gt; 页面内容&lt;br/&gt; 页面内容&lt;br/&gt; &lt;/section&gt; &lt;/body&gt; &lt;/html&gt; 通过上面的方法我们就实现了css的固定定位，但是这种方法头部固定会盖住body 的滚动条，而且真机测试的时候会比较卡，还会出现固定定位的头部回弹，体验不好。具体解决办法还是需要用JS来解决。 适配 百分比适配 百分比适配只能适配宽度，但是高度没办法适配。 &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width,user-scalable=no&quot;&gt; &lt;style type=&quot;text/css&quot;&gt; body {margin: 0; } div {width: 25%; height: 100px; float: left;} .box1 {background: red;} .box2 { background: blue; } .box3 { background: green; } .box4 { background: yellow;} &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div class=&quot;box1&quot;&gt;&lt;/div&gt; &lt;div class=&quot;box2&quot;&gt;&lt;/div&gt; &lt;div class=&quot;box3&quot;&gt;&lt;/div&gt; &lt;div class=&quot;box4&quot;&gt;&lt;/div&gt; &lt;/body&gt; &lt;/html&gt; Viewport适配 &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script type=&quot;text/javascript&quot;&gt; (function(){ var w = window.screen.width; //获取当前屏幕的尺寸 var targetW = 320; //目标尺寸 var scale = w/targetW; //当前尺寸/目标尺寸 var meta = document.createElement(&quot;meta&quot;); meta.name = &quot;viewport&quot;; meta.content = &quot;user-scalable=no,initial-scale=&quot;+scale+&quot;,minimum-scale=&quot;+scale+&quot;,maximum-scale=&quot;+scale+&quot;&quot; document.head.appendChild(meta); })(); &lt;/script&gt; &lt;!-- &lt;meta name=&quot;viewport&quot; content=&quot;user-scalable=no,initial-scale=1.0,minimum-scale=1.0,maximum-scale=1.0&quot;&gt; --&gt; &lt;style type=&quot;text/css&quot;&gt; body { margin: 0; } div { width: 80px; height: 100px; float: left; } .box1 { background: red; } .box2 { background: blue; } .box3 { background: green; } .box4 { background: yellow; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div class=&quot;box1&quot;&gt;&lt;/div&gt; &lt;div class=&quot;box2&quot;&gt;&lt;/div&gt; &lt;div class=&quot;box3&quot;&gt;&lt;/div&gt; &lt;div class=&quot;box4&quot;&gt;&lt;/div&gt; &lt;/body&gt; &lt;/html&gt;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[vuejs初探]]></title>
      <url>%2F2017%2F04%2F30%2Fvuejs%E5%88%9D%E6%8E%A2%2F</url>
      <content type="text"><![CDATA[Vue.js（读音 /vjuː/，类似于 view） 是一套构建用户界面的渐进式框架。与其他重量级框架不同的是，Vue 采用自底向上增量开发的设计。Vue 的核心库只关注视图层，它不仅易于上手，还便于与第三方库或既有项目整合。另一方面，当与单文件组件和 Vue 生态系统支持的库结合使用时，Vue 也完全能够为复杂的单页应用程序提供驱动。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[高德地图JSAPI入门]]></title>
      <url>%2F2017%2F04%2F29%2F%E9%AB%98%E5%BE%B7%E5%9C%B0%E5%9B%BEJSAPI%E5%85%A5%E9%97%A8%2F</url>
      <content type="text"><![CDATA[JS-API页面地址： http://lbs.amap.com/api/javascript-api/summary-3/ 轻捷的架构 API文件极小，简单易用 模块化地图功能，各模块按需加载 灵活开放的接口设计 支持用户自定义点标记、信息窗口等的样式 支持用户自定义插件工具，灵活的进行地图操作 丰富的可视化效果 地图拖拽、缩放平滑流畅 点标记、信息窗体效果绚丽 兼容各种浏览器 桌面端：IE6.0+、Chrome、Firefox 3.5+、Safari 3.0+、 Opera 9.0+ 移动端：IOS、Android、Windows Phone等移动平台浏览器 简单地图对象构建 设置城市(setCity) var map = new AMap.Map(&apos;map&apos;); map.setCity(&apos;东莞市&apos;) 获取城市的中心点(getCenter) alert(map.getCenter()) 设置缩放级别(setZoom) &amp; 获取当前级别(getZoom) map.setZoom(15); console.log(map.getZoom()); //15 地图放大(zoomIn) &amp; 缩小(zoomOut) document.getElementById(&apos;DOM节点&apos;).onclick = fucntion(){ map.zoomIn(); } //地图放大 document.getElementById(&apos;DOM节点&apos;).onclick = fucntion(){ map.zoomOut(); } //地图缩小 加载一个插件(plugin) map.plugin([&quot;AMap.MouseTool&quot;],function(){ var mousetool = new AMap.MouseTool(map); mousetool.rule(); //使用鼠标工具，在地图上画标记点 }); map.plugin([&quot;AMap.Scale&quot;],function(){ var scale = new AMap.Scale(); map.addControl(scale); //添加比例尺 }); 监听地图事件(dragend) AMap.event.addListener(map,&apos;dragend&apos;,function(){ alert(&apos;你拽我了&apos;); }) 地图类的地址： http://lbs.amap.com/api/javascript-api/reference/map/ 地图控件 地图比例尺(AMap.Scale) 地图类型切换(AMap.MapType) 鹰眼控件(AMap.OverView) 工具条(AMap.ToolBar) var map = new AMap.Map(&apos;map&apos;); map.setCity(&apos;东莞市&apos;) map.plugin([&quot;AMap.Scale&quot;],function(){ var scale = new AMap.Scale(); map.addControl(scale); //添加比例尺 }); map.plugin([&apos;AMap.MapType&apos;],function(){ var maptype = new AMap.MapType() map.addControl(maptype); //切换插件比如卫星视图 }) map.plugin([&apos;AMap.OverView&apos;],function(){ var overView = new AMap.OverView({isOpen:true}); map.addControl(overView); //鹰眼 overView.show(); }) map.plugin([&apos;AMap.ToolBar&apos;],function(){ var Bar = new AMap.ToolBar() //工具条，放大缩小，平移 map.addControl(Bar); }) 可将控件都传入数组里面，这样可以节省很多代码。 Marker 构建对象 传入可选参数MarkerOptions: Map, position, offset, icon, content 初始化不传MarkerOptions: 使用set系列方法 方法&amp;事件 setOffset / getOffset setPosition / getPosition setAngle / getAngle hide / show setContent / getContent setMap / getMap click mousemove dragend var marker = new AMap.Marker({ map: map, position: [113.8199286,22.8907069] }); Polyline 构建对象 传入可选参数PolylineOptions: map, position, path, strokeStyle… 初始化不传PolylineOptions: 使用set系列方法 方法&amp;事件 setPath / getPath getLength getBounds hide / show mouseover]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[微信小程序入门]]></title>
      <url>%2F2017%2F04%2F27%2Fapplet%2F</url>
      <content type="text"><![CDATA[微信小程序开发文档 https://mp.weixin.qq.com/debug/wxadoc/dev/ 笔记是参考自己写的项目做的，所以只有我看的懂，其他人仅供参考。 移动设备的分辨率与rpx pt也称为逻辑分辨率。 pt的大小和屏幕尺寸有关系，简单可以理解为长度和视觉单位。 px指物理分辨率，和屏幕尺寸没有关系。点能有大小吗？ 1个pt可以有1个px构成，也可以有2个，还可以有3个甚至更多组成。 1个pt有2个px，就已经到达人类视网膜的极限，所以如果再有更多的px也不会给我们一种更清晰的感觉。 如何做不同分辨率的自适应？ 以ip6的物理像素750 x 1334为视觉稿进行设计，而在小程序中使用rpx为单位 Ip6下1px = 1rpx = 0.5pt； 使用rpx，小程序会自动在不同的分辨率下进行转换，而使用px为单位不会。 什么是微信小程序？ 一套用来开发做微信中运行的手机app框架。 张小龙这样定义： 不需要下载安装即可使用。 用户“用完即走”，不用关系你是否安装太多应用。 应用无处不在，随时可用。 小程序的特点 小程序适合做简单的、用完即走的应用。 小程序适合低频的应用。 小程序适合性能要求不高的应用。 组成结构 结构文件：wxml； 样式文件：wxss; 逻辑成交互文件：javascript; 底层框架的工作原理 这个框架是双向的数据绑定系统：用户做视图上的修改会自动同步到数据模型中去，同样的，如果数据模型中的值发生了变化，也会立刻同步到视图中去。 必要的文件 app.js ：是小程序的脚本代码。我们可以在这个文件中监听并处理小程序的生命周期函数、声明全局变量。调用框架提供的丰富的 API。 app.json :是对整个小程序的全局配置。我们可以在这个文件中配置小程序是由哪些页面组成，配置小程序的窗口背景色，配置导航条样式，配置默认标题。注意该文件不可添加任何注释。 app.wxss : 是整个小程序的公共样式表。我们可以在页面组件的 class 属性上直接使用 app.wxss 中声明的样式规则。 创建页面 在这个教程里，我们有两个页面，index 页面和 logs 页面，即欢迎页和小程序启动日志的展示页，他们都在 pages 目录下。微信小程序中的每一个页面的【路径+页面名】都需要写在 app.json 的 pages中，且 pages 中的第一个页面是小程序的首页。 标签 view 视图容器，类似于html5中的div scroll-view 类似于html5中自带overflow:hidden的div swiper 滑块视图容器。 其中只可放置 &lt;swiper-item/&gt;组件，否则会导致未定义的行为。 宽高只能设置到swiper，swiper-item不能设置宽高。 添加属性vertical=”true”,可以纵向滚动，官方API里没有说明 swiper-item 仅可放置在 组件中，宽高自动设置为100%。 text 在小程序中，text类似于html5中的p。文本 支持转义符”\”。 组件内只支持 嵌套。 除了文本节点以外的其他节点都无法长按选中。 wx:if wx:if=”false“ 逻辑判断 在任何标签里传入wx:if=”false“，就能阻止掉当前标签的显示。如果双大括号里天true，就能显示该标签 wx:for wx:for=&quot;{{}}&quot; 括号里传入数据的变量名， wx:for-item=&quot;item&quot; for循环默认子元素指代是以item来命名的。所以block标签内写不写都无所谓。item指定子元素本身 wx:for-index=&quot;idx&quot; 可以用idx来指定子元素序号 require 加载数据模块 var postData = require(&apos;../../data/posts-data.js&apos;) module.exports 导出数据模块 module.exports={ postList:local_database } Swiper组件 滑块视图容器。详情参考 https://mp.weixin.qq.com/debug/wxadoc/dev/component/swiper.html 实现自动轮播，以及划动切换页面 &lt;swiper indicator-dots=&quot;true&quot; autoplay=&quot;true&quot; interval=&quot;5000&quot;&gt; &lt;swiper-item&gt; &lt;image src=&quot;/image/wx.png&quot;&gt;&lt;/image&gt; &lt;/swiper-item&gt; &lt;swiper-item&gt; &lt;image src=&quot;/image/vr.png&quot;&gt;&lt;/image&gt; &lt;/swiper-item&gt; &lt;swiper-item&gt; &lt;image src=&quot;/image/iqiyi.png&quot;&gt;&lt;/image&gt; &lt;/swiper-item&gt; &lt;/swiper&gt; App.json里的关于导航栏，标题的配置 Page页面与应用程序的生命周期 onLoad:function(options){ // 页面初始化 options为页面跳转所带来的参数 }, onReady:function(){ // 页面渲染完成 console.log(&apos;onReady&apos;) }, onShow:function(){ // 页面显示 console.log(&apos;onShow&apos;) }, onHide:function(){ // 页面隐藏 console.log(&apos;onHide&apos;) }, onUnload:function(){ // 页面关闭 console.log(&apos;onUnload&apos;) } 数据绑定 我们可以自己写入数据 var post_contentl={ date:&quot;sep 18 2017&quot;, title:&quot;正是虾肥蟹壮时&quot;, img:{ post_img:&quot;/image/post/crab.png&quot;, author_img:&quot;/image/avatar/1.png&quot; }, content:&quot;现在鳌山湾里最出名的就是手钓鲈鱼了！”据青岛市海洋与渔业局渔业处的工作人员介绍，鳌山湾位于崂山湾的北部，起自鳌山头，绕鳌山卫、温泉、王村、洼里4处乡镇沿岸，至女岛，形成长约15公里的湾口，面积约250平方公里，水深2—10米。&quot;, view_num:&quot;112&quot;, collect_num:&quot;96&quot;, } this.setData(post_contentl); 把数据放入上面的生命周期函数里，只要通过this.setData(post_contentl)，括号内传入json变量，就可以直接把数据添加到Data{}中。 而后在wxml中用{{}}把数据传进去。 数据绑定的运算与逻辑 AppData区域 事件与事件对象 在小程序中，任何事件都要在前面加上bind(冒泡)或catch(非冒泡)，一般bind使用比较多。 tap 类似于js中的onclick，但是默认是冒泡的，如果不想它冒泡，可以用catchtap。微信小程序中的事件是卸载行间的。 wx.navigateTo(OBJECT) 保留当前页面，跳转到应用内的某个页面，使用wx.navigateBack可以返回到原页面。 wx.redirectTo(OBJECT) 关闭当前页面，跳转到应用内的某个页面。 缓存 列表渲染(核心知识) Template模板的使用(核心知识) &lt;block wx:for=&quot;{{posts_key}}&quot; wx:for-item=&quot;item&quot;&gt; &lt;view class=&quot;post-container&quot;&gt; &lt;view class=&quot;post-author-date&quot;&gt; &lt;image class=&quot;post-author&quot; src=&quot;{{item.avatar}}&quot;&gt;&lt;/image&gt; &lt;text class=&quot;post-date&quot;&gt;{{item.date}}&lt;/text&gt; &lt;/view&gt; &lt;text class=&quot;post-title&quot;&gt;{{item.title}}&lt;/text&gt; &lt;image class=&quot;post-image&quot; src=&quot;{{item.imgSrc}}&quot;&gt;&lt;/image&gt; &lt;text class=&quot;post-content&quot;&gt;{{item.content}}&lt;/text&gt; &lt;view class=&quot;post-like&quot;&gt; &lt;image class=&quot;post-like-image&quot; src=&quot;../../image/icon/chat.png&quot;&gt;&lt;/image&gt; &lt;text class=&quot;post-like-image&quot;&gt;{{item.reading}}&lt;/text&gt; &lt;image class=&quot;post-like-image&quot; src=&quot;../../image/icon/view.png&quot;&gt;&lt;/image&gt; &lt;text class=&quot;post-like-image&quot;&gt;{{item.collection}}&lt;/text&gt; &lt;/view&gt; &lt;/view&gt; &lt;/block&gt; 通过上面的代码，我们看到wx:for里面有很多代码，那么可以把它里面的代码放到其他文件专门存储起来吗，微信给我们提供了一个template模板来实现夸页面来获取这段数据 如果wx:for想跨页面获取数据,就必须用templat模板来获取。 新建一个目录文件夹，再分别新建一个template.wxml和template.wxss。 因为template是一个模板而不是一个模块，所以创建js文件也是不会被运行的。 在template.wxml文件里写一个 &lt;template name=&quot;postItem&quot;&gt; &lt;/template&gt;标签，需要指定一个name名字，然后把wx:for里面的内容放入这个标签里 &lt;template name=&quot;postItem&quot;&gt; &lt;view class=&quot;post-container&quot;&gt; &lt;view class=&quot;post-author-date&quot;&gt; &lt;image class=&quot;post-author&quot; src=&quot;{{item.avatar}}&quot;&gt;&lt;/image&gt; &lt;text class=&quot;post-date&quot;&gt;{{item.date}}&lt;/text&gt; &lt;/view&gt; &lt;text class=&quot;post-title&quot;&gt;{{item.title}}&lt;/text&gt; &lt;image class=&quot;post-image&quot; src=&quot;{{item.imgSrc}}&quot;&gt;&lt;/image&gt; &lt;text class=&quot;post-content&quot;&gt;{{item.content}}&lt;/text&gt; &lt;view class=&quot;post-like&quot;&gt; &lt;image class=&quot;post-like-image&quot; src=&quot;../../image/icon/chat.png&quot;&gt;&lt;/image&gt; &lt;text class=&quot;post-like-image&quot;&gt;{{item.reading}}&lt;/text&gt; &lt;image class=&quot;post-like-image&quot; src=&quot;../../image/icon/view.png&quot;&gt;&lt;/image&gt; &lt;text class=&quot;post-like-image&quot;&gt;{{item.collection}}&lt;/text&gt; &lt;/view&gt; &lt;/view&gt; &lt;/template&gt; 然后要在wx:for所在的文件里引用这个templa模板，需要在文件顶部写入代码引用。 wxml文件 &lt;import src=&quot;post-item/post-item-template.wxml&quot;/&gt; //src是template模板的路径 wxss文件 @import &quot;post-item/post-item-template.wxml&quot;; //src是template模板的路径 继续在wx:for所在的标签下，写一个 &lt;template is=&quot;postItem&quot; data=&quot;&quot;/&gt; 用这个标签来获取template模板下的数据。 &lt;block wx:for=&quot;{{posts_key}}&quot; wx:for-item=&quot;item&quot;&gt; &lt;template is=&quot;postItem&quot; data=&quot;{{item}}&quot;&gt;&lt;/template&gt; &lt;/block&gt; is是获取template模板name的名字 由于templata获取的是for循环列表里的一个，如果有要获取所有数据，需要再指定一个变量，就像是js for循环中的i一样。所以data就是用来传入这个变量的。 通过这样的方式，我们就可以精简掉wx:for循环代码。 template模板的好处，不仅限于精简掉当前页面的代码，我们可以在多个页面通过这样一句代码，引入这个模板里的数据。实现多页面复用。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[HTML5地理信息-本地存储-离线存储]]></title>
      <url>%2F2017%2F04%2F26%2FHTML5%E5%9C%B0%E7%90%86%E4%BF%A1%E6%81%AF-%E6%9C%AC%E5%9C%B0%E5%AD%98%E5%82%A8-%E7%A6%BB%E7%BA%BF%E5%AD%98%E5%82%A8%2F</url>
      <content type="text"><![CDATA[地理位置 经度 : 南北极的连接线 纬度 : 东西连接的线 位置信息从何而来 IP地址 GPS全球定位系统 Wi-Fi无线网络 基站 地理位置对象 navigator.geolocation 单次定位请求 getCurrentPosition(请求成功，请求失败，数据收集方式) 括号里传入三个参数，分别是请求成功的回调，请求失败的回调，收据收集的方式 请求成功函数 经度 : coords.longitude 纬度 : coords.latitude 准确度 : coords.accuracy 海拔 : coords.altitude 海拔准确度 : coords.altitudeAcuracy 行进方向 : coords.heading 地面速度 : coords.speed 时间戳 : new Date(position.timestamp) 请求失败函数 失败编号 ：code 0 : 不包括其他错误编号中的错误 1 : 用户拒绝浏览器获取位置信息 2 : 尝试获取用户信息，但失败了 3 : 设置了timeout值，获取位置超时了 数据收集 : json的形式 enableHighAcuracy : 更精确的查找，默认false timeout : 获取位置允许最长时间，默认infinity maximumAge : 位置可以缓存的最大时间，默认0 代码： oInput.onclick = function(){ navigator.geolocation.getCurrentPosition(function(position){ oT.value += &apos;经度：&apos; + position.coords.longitude + &apos;\n&apos;; oT.value += &apos;维度：&apos; + position.coords.latitude + &apos;\n&apos;; oT.value += &apos;准确度:&apos; + position.coords.accuracy + &apos;\n&apos;; oT.value += &apos;海拔:&apos; + position.coords.altitude + &apos;\n&apos;; oT.value += &apos;海拔准确度:&apos; + position.coords.altitudeAcuracy + &apos;\n&apos;; oT.value += &apos;行进方向：&apos; + position.coords.heading + &apos;\n&apos;; oT.value += &apos;地面速度：&apos; + position.coords.speed + &apos;\n&apos;; oT.value += &apos;时间戳:&apos; + new Date(position.timestamp) + &apos;\n&apos;; },function(err){ alert(err.code); },{ enableHighAcuracy : true, //更精确的查找，默认false timeout : 5000, //获取位置允许最长时间，默认infinity maximumAge : 5000 //位置可以缓存的最大时间，默认0 }); } 多次定位请求 watchPosition(像setInterval) 移动设备有用，位置改变才会触发 配置参数：frequency 更新的频率 关闭更新请求 : clearWatch(像clearInterval) 多次请求代码： oInput.onclick = function(){ timer=navigator.geolocation.watchPosition(function(position){ oT.value += &apos;经度：&apos; + position.coords.longitude + &apos;\n&apos;; oT.value += &apos;维度：&apos; + position.coords.latitude + &apos;\n&apos;; oT.value += &apos;准确度:&apos; + position.coords.accuracy + &apos;\n&apos;; oT.value += &apos;海拔:&apos; + position.coords.altitude + &apos;\n&apos;; oT.value += &apos;海拔准确度:&apos; + position.coords.altitudeAcuracy + &apos;\n&apos;; oT.value += &apos;行进方向：&apos; + position.coords.heading + &apos;\n&apos;; oT.value += &apos;地面速度：&apos; + position.coords.speed + &apos;\n&apos;; oT.value += &apos;时间戳:&apos; + new Date(position.timestamp) + &apos;\n&apos;; },function(err){ alert(err.code); navigator.geolocation.clearWatch(timer); },{ enableHighAcuracy : true, //更精确的查找，默认false timeout : 5000, //获取位置允许最长时间，默认infinity maximumAge : 5000, //位置可以缓存的最大时间，默认0 frequency : 1000 //更新的频率， }); } 本地存储 cookie : 存储数据 当用户访问某个网站的时候，我们就可以通过cookie来向访问者的电脑上存 储数据。 1.不同的浏览器存放的cookie位置不一样，也是不能通用的。 2.cookie的存储是以域名形式进行区分的。 3.cookie的数据可以设置名字。 4.一个域名下存放的cookie的个数是有限制的，不同的浏览器存放的个数不一样。每个域名100个cookie,每组值大小4KB 5.每个cookie存放的内容大小也是有限制的，不同的浏览器存放的大小是不一样的。 document.cookie = &apos;username=tang&apos;; 我们通过document.cookie来获取当前网站下的cookie的时候，得到的是字符串形式的值，它包含了当前网站下所有的cookie。他会把所有的cookie通过分号 + 空格的形式链接起来。 chorme下是不可以操作本地cookie，不过我们做网站一般也不会用在本地，所以不用担心 如果我们想长时间存放一个cookie。需要在设置这个cookie的时候同时设定一个过期的时间。 var oDate = new Date(); oDate.setDate(oDate.getDate()+5); document.cookie = &apos;username=tang;expires=&apos; + oDate ; //这样就能将cookie值保存到5天以后。 上面的代码在IE下回出现错误，我们还需要将时间转成字符串的形式，才能兼容IE。 Document.cookie = ‘名称=值;expires=’ + 字符串形式的时间; Var oDate = new Date(); oDate.setDate(oDate.getDate() + 5); 表示保存的时间是 当前获取的时间 + 5天 //oDate.toGMTString(); 将时间转成字符串独有的写法。 Document.cookie = ‘username=leo;expires=’ + oDate.toGMTString(); // 正确的书写示例。 当我们将中文汉字等一些特殊字符存放成cookie的时候，需要使用encodeURI将特殊字符转换整计算机字符编码。 encodeURI() : 编码。 decodeURI() : 解码。 比如 Document.cookie = &apos;username=leo\n你好;expires=&apos; + oDate.toGMTString();是错误的写法。 正确 document.cookie =&apos;username =&apos; + encodeURI(&apos;leo\n你好&apos;) + &apos;;expires=&apos; + oDate.toGMTString(); 如果我们想要通过cookie的key值获取对应的value值，就需要自己封装一个函数。 代码 var oDate = new Date(); oDate.setDate(oDate.getDate()+5); document.cookie = &apos;username=tang;expires=&apos; + oDate.toGMTString() ; document.cookie = &apos;age=30&apos;; setCookie(&apos;sex&apos;,&apos;man&apos;,5); //设置cookie alert(getCookie(&apos;age&apos;)); //获取cookie removeCookie(key,&apos;&apos;,-1); //删除cookie //获取cookie的value值函数 function getCookie(key){ var arr1 = document.cookie.split(&apos;; &apos;); for(var i=0; i&lt;arr1.length; i++){ var arr2 = arr1[i].split(&apos;=&apos;); if(arr2[0] == key){ return decodeURI(arr2[1]); } } } //设置cookie值函数 function setCookie(key,value,t){ var oDate = new Date(); oDate.setDate(oDate.getDate()+t); document.cookie = key + &apos;=&apos; + value + &apos;;expires=&apos; + oDate.toGMTString(); } //删除cookie function removeCookie(key){ setCookie(key,&apos;&apos;,-1); } Storage storage和cookie差不多一样，不过cookie的设置，获取，删除等方法，需要我们自己去封装函数来实现，而storage自带了这些方法。 存储量限制 ( 5M ) 客户端完成，不会请求服务器处理 sessionStorage数据是不共享、仅针对当前窗口。 localStorage共享 sessionStorage session临时回话，从页面打开到页面关闭的时间段 窗口的临时存储，页面关闭，本地存储消失 localStorage 永久存储（可以手动删除数据） Storage API setItem(): 设置数据，key\value类型，类型都是字符串 可以用获取属性的形式操作 getItem(): 获取数据，通过key来获取到相应的value removeItem(): 删除数据，通过key来删除相应的value clear(): 删除全部存储的值 示例代码 &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;本地存储&lt;/title&gt; &lt;script&gt; window.onload = function(){ var aInput = document.getElementsByTagName(&apos;input&apos;); aInput[0].onclick = function(){ window.sessionStorage.setItem(&apos;username&apos;,aInput[3].value); //设置 } aInput[1].onclick = function(){ alert(window.sessionStorage.getItem(&apos;username&apos;)); //获取 } aInput[2].onclick = function(){ window.sessionStorage.removeItem(&apos;username&apos;); //删除 window.sessionStorage.clear(); //删除全部数据 } } &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;input type=&quot;button&quot; value=&quot;设置&quot;&gt; &lt;input type=&quot;button&quot; value=&quot;获取&quot;&gt; &lt;input type=&quot;button&quot; value=&quot;删除&quot;&gt; &lt;input type=&quot;text&quot;&gt; &lt;/body&gt; 利用本地存储做了一个小demo，关闭页面之后存储输入的信息，重新打开页面之后恢复之前存储的信息。 &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;本地存储&lt;/title&gt; &lt;script&gt; window.onload = function(){ var aInput = document.getElementsByTagName(&apos;input&apos;); var oT = document.getElementById(&apos;t1&apos;); if(window.localStorage.getItem(&apos;name&apos;)){ aInput[0].value = window.localStorage.getItem(&apos;name&apos;); } if(window.localStorage.getItem(&apos;sex&apos;)){ for(var i=1; i&lt;aInput.length; i++){ if(aInput[i].value == window.localStorage.getItem(&apos;sex&apos;)){ aInput[i].checked = true; } } } if(window.localStorage.getItem(&apos;content&apos;)){ oT.value = window.localStorage.getItem(&apos;content&apos;); } window.onunload = function(){ if(aInput[0].value){ window.localStorage.setItem(&apos;name&apos;,aInput[0].value); } for(var i=1; i&lt;aInput.length; i++){ if(aInput[i].checked == true){ window.localStorage.setItem(&apos;sex&apos;,aInput[i].value); } } if(oT.value){ window.localStorage.setItem(&apos;content&apos;,oT.value); } } } &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;p&gt; 用户名：&lt;input type=&quot;text&quot;&gt; &lt;/p&gt; &lt;p&gt; 性别：&lt;input type=&quot;radio&quot; value=&quot;男&quot; name=&quot;sex&quot;&gt;男 &lt;input type=&quot;radio&quot; value=&quot;女&quot; name=&quot;sex&quot;&gt;女 &lt;/p&gt; 内容：&lt;textarea name=&quot;content&quot; id=&quot;t1&quot; cols=&quot;30&quot; rows=&quot;10&quot;&gt;&lt;/textarea&gt; &lt;/body&gt; &lt;/html&gt; 存储事件 当数据有修改或删除的情况下，就会触发storage事件,但是在对数据进行改变的窗口对象上是不会触发的 Key : 修改或删除的key值，如果调用clear(),key为null newValue : 新设置的值，如果调用removeStorage(),key为null oldValue : 调用改变前的value值 storageArea : 当前的storage对象 url : 触发该脚本变化的文档的url 注意：只有localStorage才能在不同窗口下执行storage事件 例子：同步购物车 在一个页面选中一件商品的时候，另一个页面也会同步更新选中这个商品 &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;同步购物车&lt;/title&gt; &lt;script&gt; window.onload = function(){ var aInput = document.getElementsByTagName(&apos;input&apos;); for(var i=0; i&lt;aInput.length; i++){ aInput[i].onclick = function(){ if(this.checked){ window.localStorage.setItem(&apos;sel&apos;,this.value); } else{ window.localStorage.setItem(&apos;onsel&apos;,this.value); } } } window.addEventListener(&apos;storage&apos;,function(ev){ if(ev.key == &apos;sel&apos;){ for( var i=0; i&lt;aInput.length; i++){ if(ev.newValue == aInput[i].value){ aInput[i].checked = true; } } } else if(ev.key == &apos;onsel&apos;){ for( var i=0; i&lt;aInput.length; i++){ if(ev.newValue == aInput[i].value){ aInput[i].checked = false; } } } },false) } &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;input type=&quot;checkbox&quot; value=&quot;香蕉&quot;&gt;香蕉&lt;br&gt; &lt;input type=&quot;checkbox&quot; value=&quot;平果&quot;&gt;平果&lt;br&gt; &lt;input type=&quot;checkbox&quot; value=&quot;西瓜&quot;&gt;西瓜&lt;br&gt; &lt;input type=&quot;checkbox&quot; value=&quot;哈密瓜&quot;&gt;哈密瓜&lt;br&gt; &lt;/body&gt;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[离线存储]]></title>
      <url>%2F2017%2F04%2F26%2F%E7%A6%BB%E7%BA%BF%E5%AD%98%E5%82%A8%2F</url>
      <content type="text"><![CDATA[]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[HTML5之离线存储 || workers]]></title>
      <url>%2F2017%2F04%2F15%2FHTML5%E4%B9%8B%E7%A6%BB%E7%BA%BF%E5%AD%98%E5%82%A8%2F</url>
      <content type="text"><![CDATA[离线应用 离线应用是什么？ 乘坐飞机、手机信号弱、去演讲的时候，可能没有网络，这个时候就可以采用离线应用。 离线存储如何工作的？ 客户端向服务器请求数据的时候，服务器不但向客户端发送了一份数据，还向离线应用里也发送一份数据。当客户端第二次请求数据的时候，就不会再向服务器请求，而是直接去离线应用拿数据。 离线存储的好处？ 没网的时候，可以正常访问 快速响应页面，不必用多个HTTP占用资源带宽 缓存的可以是任何文件 搭建离线应用程序 服务器设置头信息 AddType text/cache-manifest.manifest Apache服务器是在httpd.conf文件里添加AddType text/cache-manifest.manifest html标签加 manifest=”xxxxx.manifest” 写manifest文件 : 离线的清单列表 新建manifest文件文件在里面写入代码 manifest文件可以写入任何东西 先写 : CACHE MANIFEST FALLBACK : 第一个网络地址没获取到，就走第二个缓存的 NETWORK ：无论缓存中存在与否，均从网络获取 CACHE MANIFEST 2.png FALLBACK style1.css style2.css //第一个网络地址没获取到，就走第二个缓存的 NETWORK //无论缓存中存在与否，均从网络获取 Web Workers 什么是worker JS是单线程，当处理程序过多的时候，就会卡死，没出现workers的时候都用定时器来实现（放入UI队列的个数，利用定时器解决） 可以让web应用程序具备后台处理能力，对多线程的支持非常好 Worker API new Worker(‘后台处理的JS地址’) 利用postMessage传输数据 在Web Worker中有一个语法叫self，self就是new Worker()对象 importScrpts(‘导入其他JS文件’) Worker运行环境 navgator : appName、appVersion、userAgent、platform location : 所有属性都是只读的 self : 指向全局 worker 对象 所有的ECMA对象，Object、Array、Date等 XMLHttpRequest构造器 setTimeout和setInterval方法 close()方法，立刻停止worker运行 importScripts方法]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[websocket服务器搭建与应用]]></title>
      <url>%2F2017%2F04%2F12%2Fwebsocket%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%90%AD%E5%BB%BA%E4%B8%8E%E5%BA%94%E7%94%A8%2F</url>
      <content type="text"><![CDATA[互联网协议 http://www.ruanyifeng.com/blog/2012/05/internet_protocol_suite_part_i.html Tcp/Ip协议 定义了电子设备如何连入因特网，以及数据在它们之间如何传输的标准。 传输数据（协议）的类型：比如Email，www,FTP,HTTP等 HTTP协议 浏览器和万维网服务器之间互相通信的规则 HTTP协议很强大，但也有短板，它的连接方式是短连接，响应完成之后连接就会断开，属于单次链接。HTTP协议只能是客户端发送信息给服务端，服务端接收到信息之后响应返回数据给客户端。服务端不能主动的给客户端发送数据，实时更新。只能是客服端请求之后，才会返回数据给客户端。并且由于是单次链接，在通信一次获取数据之后，它们之间的连接会断开，下次如果还想在获取数据，又必须重新建立连接，然后再次通信获取数据。 这种通信在实时交互的时候会发生很大的问题，比如，股票，聊天室，网友等应用，实时性要求比较高的时候，这种弊端就会被成倍放大。 如何实现实时应用呢，常用的方式有两种，一种是服务器推送，一种Ajax轮询。 Ajax轮询就是通过ajax异步发送一个请求，然后把数据拿过来，再然后每隔一段时间，就向服务器发送一次请求，类似于定时器一样，通过不间断的请求，保证内容的实时更新。不过这种方式，会造成服务器很大的压力，以及网络上的巨大开销。 后来在HTML5中提出websocket这种概念。 websocket websocket是基于TCP的双向的、全双工的数据连接。通过客户端向服务端发送请求，请求成功之后，它们之间的连接就会永远保持着。就像打通电话之后不挂断，客户端可以随时向服务端请求数据，服务端只有有更新，也可以随时向客户端推送信息。搭建websocket服务器有很多种方式，但是作为前端，我当然要用nodejs去搭建websocket服务器。 nodejs简介：nodejs是Ryan Dahl基于GogleV8引擎创建的一套用来编写高性能网络服务器的ECMAScript工具包，nodejs是用js去写服务器应用。 搭建服务器 配置服务器环境之前，要先去node官网下载nodejs。 nodejs的环境配置，我们略过，不懂的去百度。 首先创建一个server.js文件，在文件里先加载一个http模块，用require去加载它 var http = require(‘http’); http模块下有一个createServer的方法。调用这个方法之后，我们就创建了一个服务器 同时需要这个服务器去监听一个相关端口. var http = require(&apos;http&apos;); var serv = http.createServer().listen(8888); 然后我们需要打开node工具，进入server.js的目录下，输入node server.js指令，回车，启动服务器。可以先console.log()测试下。 var http = require(&apos;http&apos;); var serv = http.createServer().listen(8888); console.log(&apos;服务器开启成功&apos;)； 输入node server.js指令之后，如果命令行打印出服务器开启成功，就表示成功开启服务器了。 在http.createServer()括号里有一个回调函数，函数括号里传入两个值，分别是请求，响应。用户发送一个HTTP请求过来的时候，会被http.createServer().listen(8888)监听到，并且触发这个回调函数的执行。 var http = require(&apos;http&apos;); var serv = http.createServer(function(req,res){ console.log(&apos;有人进来了&apos;); }).listen(8888); 在浏览器网址栏输入localhost:8888 这个时候，命令行就会打印出 有人进来了。服务器搭建好了，当然我们不可能就写一个这么简单的服务器。 当用户发送一个请求过来，我想往客户端输出一些内容，这个使用运用到res(response)它底下的一些方法，来实现请求的发送。它下面有个write方法。 var http = require(&apos;http&apos;); var serv = http.createServer(function(req,res){ console.log(&apos;有人进来了&apos;); res.writeHeader(200,{ //输出头信息 &apos;content-type&apos;: &apos;text/html;charset=&quot;utf-8&quot;&apos; //这里表示输出的文件格式，编码是utf-8 }) res.write(&apos;这是正文部分&apos;); //向浏览器页面输出的内容 res.end(); res.writeHeader(404,{ &apos;content-type&apos;: &apos;text/html;charset=&quot;utf-8&quot;&apos; //输出头信息 }) res.write(&apos;你访问的页面去吃饭了&apos;); //向浏览器页面输出的内容 res.end(); console.log(req); }).listen(8888); 这就是一个简单的页面输入处理，当然我们不可能把要输出的内容写在这里。一般情况下，我们需要通过一些其他的模块，比如说文件操作模块去读取这个内容。要使用文件操作模块，必须先分析用户请求的资源类型。用户请求什么东西，需要通过req(request)这个对象得到的，它下面有一个url。我们可以通过console.log(req)来打印出这个对象下的所有信息。 如果用户请求的是localhost:8888/index.html。那么req(request)下面的url就会输出index.html目录。而这个时候我们需要通过用户传入的这个目录，去找我们设定好的目录下的这个文件，返回给用户。 在这之前我们需要在根目录下创建一个存放index.html的目录。我是在根目录下创建了一个叫www的文件夹，然后在这个文件里创建一个index.html文件。 用户发来请求目录的时候，我要返回目录下的这个文件，需要用一个fs模块，来读取文件。 fs模块 文件系统模块，用require去加载这个模块 var fs = require(‘fs’); fs下面有一个readFile，用来读取文件。 fs.readFile( file,function(err,data){} ); readFile()括号内有两个参数，第一个是读取的文件，第二个是读取文件的回调函数。函数传入的两个值，第一个是读取失败时候的值，另一个就是读取成功返回的数据。 var http = require(&apos;http&apos;); var fs = require(&apos;fs&apos;); //加载文件系统模块 var documentRoot = &apos;E:/websocket/www&apos;; //在这里设定我们的根目录 var httpServer = http.createServer(function(req,res){ var url = req.url; var file = documentRoot + url; //这就是文件目录的绝对路径 console.log(file) //可以在命令行查看文件的绝对路径 fs.readFile(file,function(err,data){ if(err){ res.writeHeader(404,{ //如果有错误，就输入到页面一个头部信息 &apos;content-type&apos;: &apos;text/html;charset=&quot;utf-8&quot;&apos; }); res.write(&apos;&lt;h1&gt;404&lt;/h1&gt;&lt;/p&gt;你要找的页面被狗吃了&lt;/p&gt;&apos;); res.end(); } else{ res.writeHeader(200,{ //文件获取成功，就返回用户请求的index.html &apos;content-type&apos;: &apos;text/html;charset=&quot;utf-8&quot;&apos; }); res.write(data); res.end(); } }) }).listen(8888); 安装websocket 首先打开node.js，转到项目目录在命令行输入npm install socket.io安装websocket模块。 在js文件里面引入下载的这个包 var io = require(‘socket.io’); 用这个包去监听httpServer; var socket = io.listen(‘httpServer’); 后续更新]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[JS模块化]]></title>
      <url>%2F2017%2F04%2F12%2FJS%E6%A8%A1%E5%9D%97%E5%8C%96%2F</url>
      <content type="text"><![CDATA[关于浏览器JS的模块化目前有两个比较受关注的阵营。 AMD规范（ http://wiki.commonjs.org/wiki/Modules/AsynchronousDefinition） requireJS库（ http://requirejs.org/) CMD规范 Seajs采用的 http://seajs.org 服务器端模块化规范 commonJS规范（ http://www.commonjs.org/） 冲突 命名空间是为了避免多人协作开发的时候冲突 不足：1. 名字比较长，如果变成三层四层，每次调用命名空间的函数，都会写很长名字。 2. 命名空间只能降低冲突，不能完全避免。 依赖 在实际的开发中，会有很多js模块文件相互依赖，如果不实现避免，那么后面的开发将会越来越负载，变得不可维护，最后只有推到重来。 Seajs库 seajs库就是用来避免实际开放中的相互冲突和依赖。 seajs如何解决? 1.引入sea.js的库 创建一个hmtl文件，在文件里引入sea.js. &lt;script src=&quot;sea/sea.js&quot;&gt;&lt;/script&gt; 2.如何变成模块？ 创建一个module.js文件，在文件里写入以下代码 function show(){ alert(1); } function show(){ alert(2); } 上面代码中的两个show方法，会出现冲突，我们用seajs来解决这个冲突 首先需要调用seajs下的define()方法，define()括号里传入一个回调函数define(function(){}); 在这个回调函数的括号里需要传入三个参数，reauire,exports,moudle。 这三个参数是不允许修改的，可以都写，也可以都不写，或者是只写前两个，或者只写前一个。建议都带上。 require: 依赖的接口 exports: 对外提供访问的接口 module: 当前模块的相应信息 这三个接口我们会在后面的内容中详细描述 define(function(require,exports,moudle){ function show(){ alert(1); } }); 3.如何调用模块？ exports：* 对外提供接口的对象 让这个函数编程exports下面的一个属性，然后就可以外面调用到这个函数。 define(function(require,exports,moudle){ function show(){ alert(1); } exports.show = show; //让上面的show函数变成exports下面的一个属性 }); exports.show(); //想在外面调用到exports.show()函数，还需要使用seaja.use()来完成调用 我们不能再html文件里直接通过script标签来引入module.js文件，这样并不能让让exports.show()执行，需要用seajs库的seajs.use()方法来调用。 seajs.use(): 通过它才能调用到define里面的函数方法。 seajs.use()括号里传入两个参数， 第一个参数：模块的地址。 seajs.use(&apos;js/module1.js&apos;); //这个时候去调用会报错 //错误信息：&quot;NetworkError: 404 Not Found - http://localhost/sea/sea/js/module1.js&quot; 这个地址被解析成sea/sea/js/module1.js。因为使用seajs.use的时候，我们的更目录并不是以当前页面为更目录的，而是以sea.js这个文件为根目录。 那么如果我们想以当前页面为根目录的话，需要使用相对路径 seajs.use(&apos;./js/module1.js&apos;); //这样就不会报错了，并且module.js的路径也找到了 第二个参数：就是加载好的回调函数 这个回调函数括号内可以接受一个参数，参数的名字我们随便取。这个参数就代表module.js模块中的exports。现在我们就可以调用到show()函数了。 使用seajs只有通过这样的形式才能调用到模块中的方法 seajs.use(&apos;./js/module1.js&apos;,function(ex){ ex.show(); }); 通过define和seajs.use我们就可以很容易的解决掉了模块中冲突的问题。 假如另一个同事，在module2.js模块中也写了这样一个方法，那么这个时候模块路径就会起到分辨的作用。不会和module1.js起冲突 seajs.use(&apos;./js/module2.js&apos;,function(ex){ ex.show(); }); 4. 如何依赖模块？ require:模块之间依赖的接口 require(‘./module2.js’);括号内传入需要依赖的文件的相对地址。 define(function(require,exports,moudle){ require(&apos;../js/module2.js&apos;); var a = require(&apos;../js/module2.js&apos;).a; //当引入的是sea下面的模块的时候，那么require执行完的结果就是exports function show(){ alert(a); } exports.show = show; }); 构建工具 我们的开发文件传到网上到时候，会先经行压缩和合并以及一些其他的处理， 当有很多个文件的时候，用手动来压缩或合并会浪费很多时间，而且过程中还会出错误，这个时候就需要用到构建工具。 目前比较流行的线上线下构建工具gruntjs（ http://gruntjs.com/ ） 一下是部分流程，更多详细功能请参考gruntjs官网。 安装流程 先安装nodejs和npm(包管理工具) npm install -g grunt-cli npm install grunt –save-dev grunt –version //测试grunt版本 新建一个package.json文件，文件内写入代码 { &quot;name&quot;: &quot;webqq&quot;, //项目名字 &quot;version&quot;: &quot;0.1.0&quot;, //你的版本号 &quot;devDependencies&quot;: { &quot;grunt&quot;: &quot;~1.0.1&quot;, //grunt的版本号 &quot;grunt-contrib-concat&quot;: &quot;~1.0.1 &quot;, //contrib-concat是用来合并文件的插件，我们需要在这里写明插件的名称以及版本号。 &quot;grunt-contrib-uglify&quot;: &quot;~2.3.0&quot; //contrib-uglify是用来压缩文件的插件 } } //需要用到什么插件，就可以在package.json文件里写上什么插件的名字以及版本好。 配置好package.json文件之后，在命令行输入npm install，回车。 然后就会在你的目录下面下载node_modules文件夹，里面就有package.json文件里的grunt-contrib-concat插件。 再新建一个Gruntfile.js文件，配置内容 module.exports = function(grunt) { // Project configuration. grunt.initConfig({ pkg: grunt.file.readJSON(&apos;package.json&apos;), //括号内传入package.json配置文件 concat: { //concat合并任务 webqq: { //任务名 files: { //文件名 &apos;dist/main.js&apos; : [&apos;main.js&apos;,&apos;drag.js&apos;,&apos;scale.js&apos;,&apos;range.js&apos;] //新建一个main.js文件，[写入你要合并的文件] }, }, }, uglify: { //uglify 压缩文件任务 webqq: { files: { &apos;dist/main.min.js&apos;: [&apos;dist/main.js&apos;] //把main.js文件压缩之后放入main.min.js文件中 } } } }); grunt.loadNpmTasks(&apos;grunt-contrib-concat&apos;); //加载concat插件 grunt.loadNpmTasks(&apos;grunt-contrib-uglify&apos;); //加载uglify插件 grunt.registerTask(&apos;default&apos;, [&apos;concat&apos;,&apos;uglify&apos;]); //运行插件 }; 命令行输入grunt,回车，执行这个任务。 经过上面这一系列流程，就能把main.js,drag.js,scale.js,range.js这四个文件里的内容合并到一个新文件main.js里面去。 把新生成的main.js文件压缩之后放入main.min.js文件中。 seajs构建的问题 在上面我们学习了gruntjs的两个小方法,实现了代码的合并和压缩。 但是我们合并用seajs模块化的时候就出现了问题，require()依赖的地址再无法找到。 现在通过下面的学习，我们实现seajs的合并。 在上线的版本，比如合并操作的时候，define要多出两个参数： 第一个参数 ：当前模块的ID 第二个参数 ：依赖模块的数组 通过这样的方式，将模块的地址转化成模块的ID的形式调用依赖，就能实现seajs的合并。 这是main.js的代码 define(&apos;./main.js&apos;,[&apos;./drag.js&apos;,&apos;./scale.js&apos;],function( //数组里传入我们要调用依赖的模块 require,exports,module){ var oInput = document.getElementById(&apos;input1&apos;); var oDiv1 = document.getElementById(&apos;div1&apos;); var oDiv2 = document.getElementById(&apos;div2&apos;); var oDiv3 = document.getElementById(&apos;div3&apos;); require(&apos;./drag.js&apos;).drag(oDiv3); //这里调用drag.js oInput.onclick = function(){ oDiv1.style.display = &apos;block&apos;; } require(&apos;./scale.js&apos;).scale(oDiv1,oDiv2); }); define(&apos;./drag.js&apos;,[&apos;./range.js&apos;],function(require,exports,module){ //这里的第一个参数就是给这个当前模块的命名，我们命名为drag.js，和上面的调用名称一致 function drag(obj) { var disX = 0; var disY = 0; obj.onmousedown = function(ev){ var ev = ev || window.event; disX = ev.clientX-obj.offsetLeft; disY = ev.clientY-obj.offsetTop; document.onmousemove = function(ev){ var ev = ev || window.event; var L = ev.clientX - disX; var T = ev.clientY - disY; L = require(&apos;./range.js&apos;).range(L,document.documentElement.clientWidth-obj.offsetWidth,0); T = require(&apos;./range.js&apos;).range(T,document.documentElement.clientHeight-obj.offsetHeight,0); obj.style.left = L + &apos;px&apos;; obj.style.top = T + &apos;px&apos;; } document.onmouseup = function(){ document.onmousemove = null; } return false; } } exports.drag = drag; }); define(&apos;./scale.js&apos;,[&apos;./range.js&apos;],function(require,exports,module){ function scale(obj1,obj2){ var downX = 0; var downY = 0; var downW = 0; var downH = 0; obj2.onmousedown = function (ev){ var ev = ev || window.event; downX = ev.clientX; downY = ev.clientY; downW = obj1.offsetWidth; downH = obj1.offsetHeight; document.onmousemove = function(ev){ var ev = ev || window.event; var W = ev.clientX - downX + downW; var H = ev.clientY - downY + downH; W = require(&apos;./range.js&apos;).range(W,500,100); H = require(&apos;./range.js&apos;).range(H,500,100); obj1.style.width = W + &apos;px&apos;; obj1.style.height = H + &apos;px&apos;; } document.onmouseup = function(){ document.onmousemove = null; } return false; } } exports.scale = scale; }); define(&apos;./range.js&apos;,[],function(require,exports,module){ function range(val,max,min){ if(val&gt;max){ return max; } else if(val &lt; min){ return min; } else{ return val; } } exports.range = range; }); 在html中调用上面的js代码 &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;WEBQQ&lt;/title&gt; &lt;script src=&quot;../sea/sea.js&quot;&gt;&lt;/script&gt; &lt;script&gt;seajs.use(&apos;./main.js&apos;);&lt;/script&gt; &lt;style&gt; #div1 {width: 200px; height: 200px; background: red;position: absolute; display: none;} #div2 { width: 30px; height: 30px; background: yellow;position: absolute; right: 0; bottom: 0;} #div3 { width: 100px; height: 100px; background: green;position: absolute; right: 0; top: 0; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;input type=&quot;button&quot; value=&quot;弹窗&quot; id=&quot;input1&quot;&gt; &lt;div id=&quot;div1&quot;&gt; &lt;div id=&quot;div2&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;div id=&quot;div3&quot;&gt;&lt;/div&gt; &lt;/body&gt; &lt;/html&gt; seajs和gruntjs结合开发 gruntjs提供了一些插件，可以直接实现seajs的合并,不再用上面手动的方法修改。 在安装插件之前，还是需要配置package.js和Gruntfile.js，所以我们还是要新建这两个文件。 { &quot;name&quot;: &quot;webqq&quot;, &quot;version&quot;: &quot;0.1.0&quot;, &quot;devDependencies&quot;: { &quot;grunt&quot; : &quot;~0.4.2&quot;, &quot;grunt-cmd-transport&quot; : &quot;~0.3.0&quot;, &quot;grunt-cmd-concat&quot; : &quot;~0.2.7&quot;, &quot;grunt-contrib-uglify&quot; : &quot;~0.3.2&quot; } } 插件安装 grunt-cmd-transport //提取依赖 grunt-cmd-concat //合并 接下来的流程和上面的流程一样，只是插件不同而已。这里不再赘述，只是要注意一定就是有的版本号可能不稳定。 seajs的配置信息 seajs.config({ // 别名配置 alias: { &apos;es5-safe&apos;: &apos;gallery/es5-safe/0.9.3/es5-safe&apos;, &apos;json&apos;: &apos;gallery/json/1.0.2/json&apos;, &apos;jquery&apos;: &apos;jquery/jquery/1.10.1/jquery&apos; }, // 路径配置 paths: { &apos;gallery&apos;: &apos;https://a.alipayobjects.com/gallery&apos; }, // 变量配置 vars: { &apos;locale&apos;: &apos;zh-cn&apos; }, // 映射配置 map: [ [&apos;http://example.com/js/app/&apos;, &apos;http://localhost/js/app/&apos;] ], // 预加载项 preload: [ Function.prototype.bind ? &apos;&apos; : &apos;es5-safe&apos;, this.JSON ? &apos;&apos; : &apos;json&apos; ], // 调试模式 debug: true, // Sea.js 的基础路径 base: &apos;http://example.com/path/to/base/&apos;, // 文件编码 charset: &apos;utf-8&apos; }); 配置信息主要是为了来方便开发，比如别名路径很长的时候，就可以在config里做一个变量赋值，然后再use()调用这个变量。 seajs.config({ alias : { m3 : &apos;./js/module3.js&apos; } }); seajs.use(&apos;m3&apos;,function(ex){ alert(ex.a); }); 更多详细内容，请点击 https://github.com/seajs/seajs/issues/262 了解 exports和module.exports的异同 module id : 模块唯一标识 uri : 模块绝对路径 dependencies : 当前模块依赖 exports : 当前模块对外接口 define(function(require,exports,module){ alert(module.id); alert(module.uri); //uri和id的结果是一样的，因为我们都是把路径当成ID来命名 alert(module.dependencies); //找到依赖的文件../js/module2.js alert(module.exports); //这的module.exports等于上面的exports，因为exports是module.exports的引用。 var a = require(&apos;../js/module2.js&apos;).a; //当引入的是sea下面的模块的时候，那么require执行完的结果就是exports function show(){ alert(a); } exports.show = show; }); require.async 异步加载模块 require(&apos;.js/module2.js&apos;) //同步 require.async(&apos;.js/module2.js&apos;,function(){ alert(&apos;模块加载完的回调&apos;); //异步 })]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Ajax的新特性]]></title>
      <url>%2F2017%2F04%2F11%2FAjax%E7%9A%84%E6%96%B0%E7%89%B9%E6%80%A7%2F</url>
      <content type="text"><![CDATA[XMLHttpRequest Level2 标准下 XMLHttpRequest改进版 详细信心请参考XMLHttpRequest改进版新特性 https://xhr.spec.whatwg.org/ XMLHttpRequest :增加很多功能，他也不推荐使用onreadystatechange这个事件来监听，推荐使用onload 而onload事件不需要再去做判断，只有当xhr.status == 200的时候才会去触发。 1.请求页面与数据页面必须属性不同的域 2.服务器要设置响应头信息 3.origin值的展现 在标准浏览器下，XMLHttpRequest对象已经是升级版本，支持了更多的特性，可以跨域请求，如果想实现跨域请求，还需要后端的相关配合才可以。 后端需要在头信息里输入’Access-Control-Allow-origin: http://域名&#39;;(这段信息可以在chrome下的console控制台找到。) 示例： 这是www.b.com域名下的ajax.php的内容 &lt;?php header(‘Access-Control-Allow-Origin: http://www.a.com‘); //这是允许访问该资源的域 echo ‘hello’; 这事www.a.com下的ajax.html的内容 &lt;script&gt; window.onload = function() { var oBtn = document.getElementById(&apos;btn&apos;); oBtn.onclick = function() { var xhr = new XMLHttpRequest(); xhr.onreadystatechange = function() { if (xhr.readyState == 4) { if (xhr.status == 200) { alert(xhr.responseText); } } } xhr.open(&apos;get&apos;, &apos;ajax.php&apos;, true); //通过这里去访问b.com下的php文件 xhr.send(); } } &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;input type=&quot;button&quot; value=&quot;获取同域下内容&quot; id=&quot;btn&quot; /&gt; &lt;/body&gt; IE下 XDomainRequest IE下如果想实现跨域请求，则需要使用另外一个对象去实现 –&gt; XDomainRequest XDomainRequest方法不支持IE6 当然同域下，还是使用XMLHttpRequest去实现请求 XDomainRequest对象的官方说明文档 http://msdn.microsoft.com/en-us/library/cc288060(Vs.85).aspx 新的事件 ： onerror : 清楚求出错时触发 onload : 请求完成时触发 onprogress : 请求经行当中 ontimeout : 请求超时 方法 abort : 取消 open(XDomainRequest) ： 打开链接 send(XDomainRequest) ：发送请求 示例： &lt;script&gt; window.onload = function() { var oBtn = document.getElementById(&apos;btn&apos;); oBtn.onclick = function() { var oXDomainRequest = new XDomainRequest(); oXDomainRequest.onload = function() { alert(this.responseText); } oXDomainRequest.open(&apos;get&apos;, &apos;http://www.b.com/ajax.php&apos;, true); oXDomainRequest.send(); } } &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;input type=&quot;button&quot; value=&quot;获取同域下内容&quot; id=&quot;btn&quot; /&gt; &lt;/body&gt; Ajax无刷新上传 file &lt;input type=&quot;file&quot;&gt; 解释：生成一个文件上传控件，用于文件的上传。额外提供了一些属性： accept 指定接受的 MIME 类型 required 表明用户必须提供一个值，否则无法通过验证 accept=”image/gif, image/jpeg, image/png” files file控件中选择的文件列表对象 它的第0个就是我们要找的对象，它里面就是文件列表下的文件对象 oMyFile.files[0] files[0]下面会返回一些信息给我们，{size : 文件大小,type : 文件类型,slice : 方法,name : 文件名} 然后通过Ajax把它发送给后端 FormData var oFormData = new FormData(); //通过FormData来构建提交数据 oFormData.append(‘file’, oMyFile.files[0]); 括号内传入控件名，还有对象下面的文件对象 upload upload.onprogress: 监听当前文件的上传进度，进度变化的时候触发 这个事件下有两个属性，ev.total: 已发送的总量，ev.loaded : 待发送的总量。 onprogress：下载 示例： &lt;style&gt; #div1 {width: 300px; height: 30px; border: 1px solid #000; position: relative;} #div2 {width: 0; height: 30px; background: #CCC;} #div3 {width: 300px; height: 30px; line-height: 30px; text-align: center; position: absolute; left: 0; top: 0;} &lt;/style&gt; &lt;script&gt; window.onload = function() { var oBtn = document.getElementById(&apos;btn&apos;); var oMyFile = document.getElementById(&apos;myFile&apos;); var oDiv1 = document.getElementById(&apos;div1&apos;); var oDiv2 = document.getElementById(&apos;div2&apos;); var oDiv3 = document.getElementById(&apos;div3&apos;); oBtn.onclick = function() { //alert(oMyFile.value); //获取到的是file控件的value值，这个内容是显示给你看的文字，不是我们选择的文件 //oMyFile.files file控件中选择的文件列表对象 //alert(oMyFile.files); //我们是要通过ajax把oMyFile.files[0]数据发送给后端 /*for (var attr in oMyFile.files[0]) { console.log( attr + &apos; : &apos; + oMyFile.files[0][attr] ); }*/ var xhr = new XMLHttpRequest(); xhr.onload = function() { alert(&apos;OK,上传完成&apos;); } var oUpload = xhr.upload; oUpload.onprogress = function(ev) { var iScale = ev.loaded / ev.total; oDiv2.style.width = 300 * iScale + &apos;px&apos;; oDiv3.innerHTML = iScale * 100 + &apos;%&apos;; } xhr.open(&apos;post&apos;, &apos;post_file.php&apos;, true); xhr.setRequestHeader(&apos;X-Request-With&apos;, &apos;XMLHttpRequest&apos;); var oFormData = new FormData(); //通过FormData来构建提交数据 oFormData.append(&apos;file&apos;, oMyFile.files[0]); xhr.send(oFormData); } } &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;input type=&quot;file&quot; id=&quot;myFile&quot; /&gt;&lt;input type=&quot;button&quot; id=&quot;btn&quot; value=&quot;上传&quot; /&gt; &lt;div id=&quot;div1&quot;&gt; &lt;div id=&quot;div2&quot;&gt;&lt;/div&gt; &lt;div id=&quot;div3&quot;&gt;0%&lt;/div&gt; &lt;/div&gt; &lt;/body&gt; post_file.php文件内容 &lt;?php header(&apos;Content-type:text/html; charset=&quot;utf-8&quot;&apos;); $upload_dir = &apos;uploads/&apos;; if(strtolower($_SERVER[&apos;REQUEST_METHOD&apos;]) != &apos;post&apos;){ exit_status(array(&apos;code&apos;=&gt;1,&apos;msg&apos;=&gt;&apos;错误提交方式&apos;)); } if(array_key_exists(&apos;file&apos;,$_FILES) &amp;&amp; $_FILES[&apos;file&apos;][&apos;error&apos;] == 0 ){ $pic = $_FILES[&apos;file&apos;]; if(move_uploaded_file($pic[&apos;tmp_name&apos;], $upload_dir.$pic[&apos;name&apos;])){ exit_status(array(&apos;code&apos;=&gt;0,&apos;msg&apos;=&gt;&apos;上传成功&apos;,&apos;url&apos;=&gt;$upload_dir.$pic[&apos;name&apos;])); } } echo $_FILES[&apos;file&apos;][&apos;error&apos;]; exit_status(array(&apos;code&apos;=&gt;1,&apos;msg&apos;=&gt;&apos;出现了一些错误&apos;)); function exit_status($str){ echo json_encode($str); exit; } ?&gt;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[HTML5详解之跨文档通信]]></title>
      <url>%2F2017%2F04%2F10%2FHTML5%E8%AF%A6%E8%A7%A3%E4%B9%8B%E5%A4%B8%E6%96%87%E6%A1%A3%E9%80%9A%E4%BF%A1%2F</url>
      <content type="text"><![CDATA[在不同域名下的通信访问，需要配置服务器，服务器的配置略过，以下笔记太过啰嗦仅供作者本人参考。 同域下的通信方式 iframe 嵌入另一个文档 &lt;a href=&quot;index.html&quot; target=&quot;in&quot;&gt;index&lt;/a&gt; | &lt;a href=&quot;http://www.baidu.com&quot; target=&quot;in&quot;&gt;百度&lt;/a&gt; &lt;iframe src=&quot;http://www.ycku.com&quot; width=&quot;600&quot; height=&quot;500&quot;name=&quot;in&quot;&gt;&lt;iframe&gt; 解释： &lt;iframe&gt;表示内嵌一个 HTML 文档。其下的 src属性表示初始化时显示的页面， width 和 height 表示内嵌文档的长度和高度，name 表示用于 target 的名称。 我们可以通过js去访问被iframe包含页面的DOM元素 contentWindow方法 找到被iframe包含的页面的window对象，通过这个方法，我们可以去操控这个被iframe包含的页面。 示例： &lt;script&gt; window.onload = function() { var oBtn = document.getElementById(&apos;btn&apos;); var oMyIframe = document.getElementById(&apos;myframe&apos;); oBtn.onclick = function() { //如果我们要操作一个iframe里面的dom元素，首先要获取到iframe引入的页面的window //oMyIframe.contentWindow -&gt; 被iframe包含的页面的window对象 //alert(oMyIframe.contentWindow); oMyIframe.contentWindow.document.body.style.background = &apos;red&apos;; //让iframe下的body背景变成红色； } } &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;input type=&quot;button&quot; value=&quot;点击我，改变2.iframe.html的背景色&quot; id=&quot;btn&quot; /&gt; &lt;iframe id=&quot;myframe&quot; src=&quot;2.iframe.html&quot;&gt;&lt;/iframe&gt; &lt;/body&gt; window.open 当window.open打开一个写页面的时候，会返回一个值，这个值就是被打开的窗口的window对象 通过这个返回的对象，我们可以在父页面直接操控这个返回window对象的页面 示例： &lt;script&gt; window.onload = function() { var oBtn = document.getElementById(&apos;btn&apos;); var oBtn2 = document.getElementById(&apos;btn2&apos;); var newWindow = null; oBtn.onclick = function() { //window.open 返回被打开窗口的window对象 newWindow = window.open(&apos;4.window.open.html&apos;, &apos;_blank&apos;); } oBtn2.onclick = function() { newWindow.document.body.style.background = &apos;red&apos;; //让被打开的页面背景变红 } } &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;input type=&quot;button&quot; value=&quot;点击我，开启一个新的窗口打开4.window.open.html页面&quot; id=&quot;btn&quot; /&gt; &lt;input type=&quot;button&quot; value=&quot;点击我，改变4.window.open.html页面的背景色&quot; id=&quot;btn2&quot; /&gt; &lt;/body&gt; 跨域的通信方式 当本页面和包含页面不在同一个域名下的时候，这样操作就会有跨域操作安全限制的问题。 示例： &lt;script&gt; window.onload = function() { var oBtn = document.getElementById(&apos;btn&apos;); var oMyIframe = document.getElementById(&apos;myframe&apos;); oBtn.onclick = function() { //当本页面和包含页面不在同一个域名下的时候，这样操作就会有跨域操作安全限制问题。 oMyIframe.contentWindow.document.body.style.background = &apos;red&apos;; //执行结果报错 } } &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;input type=&quot;button&quot; value=&quot;点击我，改变2.iframe.html的背景色&quot; id=&quot;btn&quot; /&gt; &lt;iframe id=&quot;myframe&quot; src=&quot;http://www.b.com/2.iframe.html&quot;&gt;&lt;/iframe&gt; &lt;/body&gt; 那么如果做到跨域的通信呢，其他的解决方法暂不表诉，我们这次只运用HTML5的新方法来解决。 postMessage 作用：可以通过这个方法给另外一个窗口发送信息 写法：接受消息的窗口的windo对象.postMessage(); 括号有两个参数：第一个参数是发送的数据；第二个参数是接受的域(需带上协议http://) message 当窗口接受到通过postMessage发送过来的数据的时候触发 message事件下的event对象会保存了发送过来的内容 ev.data ：就是发送过来的数据 ev.origin : 就是发送数据来源的域 用postMessage发送消息和我们前面直接去操作DOM有很大区别，在跨域的时候，我们是不能直接去操作另一个与域名下页面的DOM，必须通过postMessage去发送一个口令，另一个域名下的页面利用message接受到这个口令之后，就会去做一些它相关处理好的一些事情。 由于有的时候我们不会只发送一个口令，所以需要判断在不同口令下做不同的事情。 还要考虑安全性方面的问题，为了识别只有a.com发来的口令才会执行，我们需要利用ev.origin来判断是否是由a.com发送，具体怎样操作请看下面的两个示例。 我们用两个不同的域名（a.com和b.com）模拟一下，下面分别给出两个不同域名下的页面代码 示例： 这是a.com下的页面 &lt;script&gt; window.onload = function() { var oBtn = document.getElementById(&apos;btn&apos;); var oMyIframe = document.getElementById(&apos;myframe&apos;); //postMessage : 可以通过这个方法给另外一个窗口发送信息 //接收消息的窗口的window对象.postMessage(); Btn.onclick = function() { //第一个参数：发送的数据 //第二个参数：接收数据的域名｛带上协议｝ oMyIframe.contentWindow.postMessage(&apos;1&apos;, &apos;http://www.b.com&apos;); //向b.com发送口令1 } } &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;input type=&quot;button&quot; value=&quot;点击我，改变2.iframe.html的背景色&quot; id=&quot;btn&quot; /&gt; &lt;iframe id=&quot;myframe&quot; src=&quot;http://www.b.com/3.postMessage.html&quot;&gt;&lt;/iframe&gt; &lt;/body&gt; 这是b.com下的页面 &lt;script&gt; window.onload = function() { //message : 当窗口接收到通过postMessage发送过来的数据的时候触发 //通过addEventListener来绑定message，使它被触发的时候操作需要发生的事件 window.addEventListener(&apos;message&apos;, function(ev) { //alert(&apos;b.com下的页面接收到了内容了&apos;); //message事件的事件对象下保存了发送过来的内容 //ev.data : 发送过来的数据 alert(&apos;我接收到了a.com页面发送过来的数据，内容是：&apos; + ev.data); &lt;!-- 用postMessage发送消息和我们前面直接去操作DOM有很大区别，在跨域 的时候，我们是不能直接去操作另一个与域名下页面的DOM，必须通过postMes sage去发送一个口令，另一个域名下的页面利用message接受到这个口令之后 ，就会去做一些它相关处理好的一些事情。 由于有的时候我们不会执法送一个口令，所以需要判断在不同口令下做不同 的事情。 还要考虑安全性方面的问题，为了识别只有a.com发来的口令才会执行，我们 需要利用ev.origin来判断是否是由a.com发送 --&gt; if(ev.origin == &apos;http://www.a.com&apos;){ //判断是否是由a.com发送的口令 if (ev.data == &apos;1&apos;) { //判断口令如果=1，就执行下面的事件 document.body.style.background = &apos;red&apos;; } } }, false); } &lt;/script&gt; &lt;/head&gt; &lt;body&gt; 这是b.com的postMessage.html页面 &lt;/body&gt; &lt;/html&gt; 同域下的交互方式 上面的内容都是父页面操控子页面，其实子页面也能操控父页面。 parent parent = window 如果当前页面是顶级，没有被其他页面所包含，那么parent就是当前页面的window对象，那么如果被包含了，则parent就是包含当前页面的父级页面的window对象，通过parent我们可以让同域下子页面操控父页面。 示例： &lt;script&gt; window.onload = function() { var oBtn = document.getElementById(&apos;btn&apos;); oBtn.onclick = function(){ parent.document.body.style.background = &apos;green&apos;; //在子页面下点击按钮也能让父级的body背景变绿。 } } &lt;/script&gt; &lt;/head&gt; &lt;body&gt; 这是b.com的postMessage.html页面 &lt;input type=&quot;button&quot; value=&quot;点击我，改a.com页面的背景色&quot; id=&quot;btn&quot; /&gt; &lt;/body&gt; &lt;/html&gt; iframe下 被iframe包含的页面我们暂且称呼它为子页面， 存放iframe标签的页面我们暂且称呼它为父页面。 父页面 ：父页面用contentWindow –&gt; 找到被iframe包含的页面(子页面)的window对象 子页面 ：子页面用window.top –&gt; 找到被包含页面(子页面)的最顶层的父页面的window对象 windo.open 窗口页 使用window.open()方法的页面我们暂且称呼它为父页面， 被window.open打开的页面我们暂且称呼它为子页面。 父页面 ：父页面用window.open –&gt; 打开的新页面(子页面)，并且返回这个新页面的window对象 子页面 ：子页面用window.opener –&gt; 找到用window.open方法打开当前页面的父页面的window对象。 示例：（ Ps: iframe的操作方式和它差不多，我们就不做表述。） 用来打开新页面的页面 &lt;script&gt; window.onload = function() { var oBtn = document.getElementById(&apos;btn&apos;); var oBtn2 = document.getElementById(&apos;btn2&apos;); var newWindow = null; oBtn.onclick = function() { //window.open 返回被打开窗口的window对象 newWindow = window.open(&apos;4.window.open.html&apos;, &apos;_blank&apos;); } oBtn2.onclick = function() { newWindow.document.body.style.background = &apos;red&apos;; //让被打开的页面背景变红 } } &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;input type=&quot;button&quot; value=&quot;点击我，开启一个新的窗口打开4.window.open.html页面&quot; id=&quot;btn&quot; /&gt; &lt;input type=&quot;button&quot; value=&quot;点击我，改变4.window.open.html页面的背景色&quot; id=&quot;btn2&quot; /&gt; &lt;/body&gt; 被打开的页面 &lt;script&gt; window.onload = function() { var oBtn = document.getElementById(&apos;btn&apos;); oBtn.onclick = function() { //window.opener : 通过window.open方法打开当前页面的窗口window window.opener.document.body.style.background = &apos;green&apos;; } } &lt;/script&gt; &lt;/head&gt; &lt;body&gt; 这是a.com下的4.window.open.html页面 &lt;input type=&quot;button&quot; value=&quot;点击我，改变3.window.open.html页面的背景色&quot; id=&quot;btn&quot; /&gt; &lt;/body&gt;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[jQ初探-常用API]]></title>
      <url>%2F2017%2F04%2F09%2FjQ-%E5%B8%B8%E7%94%A8API%2F</url>
      <content type="text"><![CDATA[JQ下的常用API，个人笔记，方便查询。 选择元素： 选择ID： $(&apos;#div1&apos;).css(&apos;background&apos;,&apos;red&apos;); 选择class： $(&apos;.box&apos;).css(&apos;background&apos;,&apos;red&apos;); 选择标签： $(&apos;div&apos;).css(&apos;background&apos;,&apos;red&apos;); $(&apos;li:first&apos;).css(&apos;background&apos;,&apos;red&apos;); 第一个 first $(&apos;li:last&apos;).css(&apos;background&apos;,&apos;red&apos;); 最后一个 last $(&apos;li:eq(2)&apos;).css(&apos;background&apos;,&apos;red&apos;); //根据下标选择第几个的元素 eq(n) $(&apos;li:even&apos;).css(&apos;background&apos;,&apos;red&apos;); //选择奇数行 even $(&apos;li:odd&apos;).css(&apos;background&apos;,&apos;red&apos;); //选择偶数行 odd PS: 选择第几个的时候必须加“ ： ”。 $(&apos;li.box&apos;).css(&apos;background&apos;,&apos;red&apos;); $(function): 相当于JS下的window.onload = function(){},但是比它的性能好 &lt;window,onload表示全部加载完再执行，而$(function(){})则是加载完DOM就执行 全写形式=$(document).ready(function(){}) JS下DOMcontentloaded具有相同的意思 兼容形式 if (document.addEventListener){ document.addEventListener(&quot;DOMContentLoaded&quot;, init, false); } 方法函数化： $(function(){ $(&apos;#div1&apos;).click(function(){ alert($(this).html()); }) }) $()下的常用方法： attr(): 可以进行属性的取值和赋值操作 &lt;script src=&quot;jquery-1.10.1.min.js&quot;&gt;&lt;/script&gt; &lt;script&gt; $(function(){ $(&apos;div&apos;).attr(&apos;title&apos;,&apos;456&apos;); //可以经行属性操作赋值 $(&apos;div&apos;).attr(&apos;class&apos;,&apos;box&apos;); alert($(&apos;div&apos;).attr(&apos;title&apos;)); //也可以经行属性取值 }) &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div title=&quot;123&quot; &gt;&lt;/div&gt; &lt;/body&gt; filter(): 对元素进行筛选过滤，针对当前元素 筛选： $(&apos;li&apos;).filter(&apos;.box&apos;).css(&apos;background&apos;,&apos;green&apos;); 筛选自定义属性： $(&apos;li&apos;).filter(&apos;[title=hello]&apos;).css(&apos;background&apos;,&apos;green&apos;); //可以筛选自定义属性 not(): filter()的反义词，针对当前元素 示例： &lt;script src=&quot;jquery-1.10.1.min.js&quot;&gt;&lt;/script&gt; &lt;script&gt; $(function(){ $(&apos;div&apos;).css(&apos;background&apos;,&apos;red&apos;); //所有div背景变红 $(&apos;div&apos;).filter(&apos;.box&apos;).css(&apos;background&apos;,&apos;green&apos;); //当前元素带有.box的div变绿 $(&apos;div&apos;).not(&apos;.box&apos;).css(&apos;background&apos;,&apos;blue&apos;); //当前元素不带有.box的变蓝 }) &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div class=&quot;box&quot;&gt;div1&lt;/div&gt; &lt;div&gt;div2&lt;/div&gt; &lt;/body&gt; has(): 元素是否包含，当前元素里面的东西 示例： &lt;script src=&quot;jquery-1.10.1.min.js&quot;&gt;&lt;/script&gt; &lt;script&gt; $(function(){ $(&apos;div&apos;).css(&apos;background&apos;,&apos;red&apos;); $(&apos;div&apos;).has(&apos;span&apos;).css(&apos;background&apos;,&apos;green&apos;); //元素里面包含span的变绿 $(&apos;div&apos;).has(&apos;.box&apos;).css(&apos;background&apos;,&apos;blue&apos;); //元素里面包含.box的变蓝 }) &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div&gt;div1&lt;span class=&quot;box&quot;&gt;span&lt;/span&gt;&lt;/div&gt; &lt;div&gt;div2&lt;/div&gt; &lt;/body&gt; add(): 组合元素 示例： &lt;script src=&quot;jquery-1.10.1.min.js&quot;&gt;&lt;/script&gt; &lt;script&gt; $(function(){ $(&apos;span&apos;).add(&apos;div&apos;).css(&apos;background&apos;,&apos;green&apos;); }); //span + div的背景都变绿 &lt;/script&gt; &lt;/head&gt; &lt;body class=&quot;box&quot;&gt; &lt;span&gt;span&lt;/span&gt; &lt;div&gt;div&lt;/div&gt; &lt;/body&gt; next(): 上一个兄弟节点 prev(): 下一个兄弟节点 示例： &lt;script src=&quot;jquery-1.10.1.min.js&quot;&gt;&lt;/script&gt; &lt;script&gt; $(function(){ $(&apos;div&apos;).next().css(&apos;background&apos;,&apos;red&apos;); //div的下一个元素变红 $(&apos;span&apos;).prev().css(&apos;background&apos;,&apos;green&apos;); //span的上一个元素变绿 }) &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div&gt;div&lt;/div&gt; &lt;span&gt;span&lt;/span&gt; &lt;/body&gt; siblings(): 获取元素所有兄弟节点，但不包括它自身，可以传入一个参数，传入的参数是你要筛选的兄弟节点 示例： &lt;script src=&quot;jquery-1.10.1.min.js&quot;&gt;&lt;/script&gt; &lt;script&gt; $(function(){ $(&apos;span&apos;).siblings().css(&apos;background&apos;,&apos;green&apos;); //span的所有兄弟节点背景变绿 $(&apos;span&apos;).siblings(&apos;h2&apos;).css(&apos;background&apos;,&apos;red&apos;); //span的兄弟节点h2背景变红 }); &lt;/script&gt; &lt;/head&gt; &lt;body class=&quot;box&quot;&gt; &lt;div&gt;div&lt;/div&gt; &lt;span&gt;span&lt;/span&gt; &lt;p&gt;p&lt;/p&gt; &lt;h2&gt;h2&lt;/h2&gt; &lt;/body&gt; nextAll(): 获取元素下面的所有兄弟节点，但不包括它自身和它上面的兄弟节点， 可以传入一个参数，传入的参数是你要筛选的兄弟节点 prevAll(): 获取元素上面的所有兄弟节点，但不包括它自身和它下面的兄弟节点， 可以传入一个参数，传入的参数是你要筛选的兄弟节点 nextUntil(): 获取元素下面的所有兄弟节点，但不包括它自身和它上面的兄弟节点， 可以传入一个参数，传入的参数是你要截止的兄弟节点 prevUntil(): 获取元素上面的所有兄弟节点，但不包括它自身和它下面的兄弟节点， 可以传入一个参数，传入的参数是你要截止的兄弟节点 find(): 查找元素里面的元素,对比$(‘div h2’), $(‘div’).find(‘h2’)的性能更高 children(): 查找元素里面的所有子节点，括号里传入筛选的参数 $(‘ul’).children(‘li’); 只获取ul下面的li 和find()的差别是： find()能获取元素下的子节点，孙子节点无线往下延伸。 children()只能获取子节点，子节点里面的节点无法获取。 eq(): 元素下标 index(): 元素索引 示例： &lt;script src=&quot;jquery-1.10.1.min.js&quot;&gt;&lt;/script&gt; &lt;script&gt; $(function(){ $(&apos;div&apos;).find(&apos;h2&apos;).css(&apos;background&apos;,&apos;red&apos;); // div里面的所有h2标签背景颜色变红 $(&apos;div&apos;).find(&apos;h2&apos;).eq(2).css(&apos;background&apos;,&apos;red&apos;); // div里面的第二个h2标签背景颜色变红 alert($(&apos;#h2&apos;).index()); //当前元素在所有兄弟节点中的位置 }) &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div&gt; &lt;h3&gt;h3&lt;/h3&gt; &lt;h2&gt;h2&lt;/h2&gt; &lt;h3&gt;h3&lt;/h3&gt; &lt;h2 id=&quot;h2&quot;&gt;h2&lt;/h2&gt; &lt;h2&gt;h2&lt;/h2&gt; &lt;h2&gt;h2&lt;/h2&gt; &lt;h3&gt;h3&lt;/h3&gt; &lt;/div&gt; &lt;/body&gt; addClass(): 添加class样式 removeClass(): 删除class样式 示例： &lt;script src=&quot;jquery-1.10.1.min.js&quot;&gt;&lt;/script&gt; &lt;script&gt; $(function(){ $(&apos;div&apos;).addClass(&apos;box3 box4&apos;); $(&apos;div&apos;).removeClass(&apos;box2 box4&apos;); }) &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div class=&quot;box1 box2&quot;&gt;div&lt;/div&gt; &lt;/body&gt; toggleClass(): 先判断元素有没有这个className,如果没有，就给给它添加，如果有就删除。 JQ中的宽高 width(): 获取元素的宽度，但是没有单位 //alert($(‘div’).width()); 赋值：$(‘div’).width(200); //元素内容宽度变成200px innerWidth(): 元素的宽度+padding 赋值：$(‘div’).innerWidth(200); //元素的总宽度是200，实际内容宽度需要减去padding值。 outerWidth(): 元素的宽度+padding+border 赋值：$(‘div’).outerWidth(200); //元素的总宽度是200，实际内容宽度需要减去padding值和边框的宽度。 PS: 以上元素不带margin outerWidth(true): 元素的宽度+padding+border+margin //()里面加true带margin 赋值：$(‘div’).outerWidth(200,true); //元素的占位宽度是200，实际内容宽度需要减去padding值和边框的宽度以及margin值。 与原生JS的区别：和原生offsetWidth一样，但是offsetWidth无法获取到隐藏元素的宽 outerWidth可以获取隐藏元素的宽 获取可视区的高：$(window).height(); //获取页面可视取的高度，宽度同理 获取页面的高：$(document).height(); //获取页面的高度，宽度同理 scrollTop(): 鼠标的纵向滚动距离 scrollLeft(): 鼠标的横向滚动距离 括号里可以传入一个数值，单位是PX，传入的数值会让滚动条滚动到这位置。 示例演示： &lt;script src=&quot;jquery-1.10.1.min.js&quot;&gt;&lt;/script&gt; &lt;script&gt; $(function(){ $(document).click(function(){ alert($(window).scrollTop()); }) }); &lt;/script&gt; &lt;/head&gt; &lt;body style=&quot;height:2000px&quot;&gt; &lt;div&gt;div&lt;/div&gt; &lt;/body&gt; jQuery方法之DOM操作： insertBefore(): 把元素添加到指定元素的前面 $(&apos;span&apos;).insertBefore(&apos;div&apos;); //把span放到div的前面 before(): 元素的前面位置应该是某元素 $(&apos;div&apos;).before(&apos;span&apos;); //在div的前面放入span Ps: 这两个方法的行为是一样，但是后续的操作变了。 insertAfter(): 把元素添加到指定元素的后面 $(&apos;span&apos;).insertAfter(&apos;div&apos;);//把span放到div的后面 after(): 元素的后面是某元素 $(&apos;div&apos;).after(&apos;span&apos;); //在div的后面放入span Ps: 这两个方法的行为是一样，但是后续的操作变了。 appendTo(): 把元素添加到指定元素的里面的最后面 $(‘span’).appendTo(‘div’); //把span放到div的里面的最后位置 append(): 元素的里面最后位置应该是某元素 $(div).append(‘span’); //div的里面的最后位置放入span prependTo(): 把元素放到指定元素的里面的开始位置 $(‘span’).prependTo(‘div’);//把span放到div的里面的开始位置 prepend(): 元素的里面的开始位置应该是某元素 $(‘div’).prepend(‘span’); //div的里面的开始位置放入span 示例演示： &lt;script src=&quot;jquery-1.10.1.min.js&quot;&gt;&lt;/script&gt; &lt;script&gt; $(function(){ //$(&apos;span&apos;).insertBefore(&apos;div&apos;); //把span放到div的前面 //$(&apos;div&apos;).insertAfter(&apos;span&apos;); //把div放到span的后面 //$(&apos;div&apos;).appendTo(&apos;span&apos;); //把div放到span里面的最后位置 //$(&apos;div&apos;).prependTo(&apos;span&apos;); //把div放到span里面的开始位置 $(&apos;span&apos;).insertBefore(&apos;div&apos;).css(&apos;background&apos;,&apos;green&apos;); //把span放到div的前面,然后span的背景变绿 $(&apos;div&apos;).before($(&apos;span&apos;)).css(&apos;background&apos;,&apos;red&apos;); //div的前面插入sapn，然后div的背景变红 }) &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div&gt;div&lt;/div&gt; &lt;span&gt;span&lt;/span&gt; &lt;/body&gt; remove(): 删除某元素并且删除这个元素的所有操作行为 $(&apos;div&apos;).remove(); //删除div元素 detach(): 删除某元素但是保留这个元素的所有操作行为 $(&apos;div&apos;).detach(); //删除div元素 示例： &lt;script src=&quot;jquery-1.10.1.min.js&quot;&gt;&lt;/script&gt; &lt;script&gt; $(function(){ $(&apos;#div1&apos;).click(function(){ alert($(&apos;#div1&apos;).html()); }) var oDiv = $(&apos;#div1&apos;).detach(); //删除之后用变量存下 $(&apos;body&apos;).append(oDiv); //然后后面插入的时候还会保留它的事件操作 }); &lt;/script&gt; &lt;/head&gt; &lt;body&quot;&gt; &lt;div id=&quot;div1&quot;&gt;div1&lt;/div&gt; &lt;/body&gt; clone(): 复制某个元素。可以传入一个参数，参数为true，可以复制这个元素的操作行为 示例： &lt;script src=&quot;jquery-1.10.1.min.js&quot;&gt;&lt;/script&gt; &lt;script&gt; $(function(){ $(&apos;span&apos;).click(function(){ alert(123); }) $(&apos;span&apos;).clone(true).appendTo(&apos;div&apos;); //把span复制到div里面，不删除原元素 }); //clone(内容为true)的时候可以复制这个元素的操作行为 &lt;/script&gt; &lt;/head&gt; &lt;body class=&quot;box&quot;&gt; &lt;div&gt;div&lt;/div&gt; &lt;span&gt;span&lt;/span&gt; &lt;/body&gt; parent(): 获取元素的父级 等于原生JS的parentNode offsetParent(): 获取有定位的父级 等于原生JS的offsetParent一样。 示例： &lt;script src=&quot;jquery-1.10.1.min.js&quot;&gt;&lt;/script&gt; &lt;script&gt; $(function(){ $(&apos;#div2&apos;).on(&apos;click&apos;,function(){ $(&apos;#div2&apos;).parent().css(&apos;background&apos;,&apos;green&apos;); //让div2的父级背景变成绿色 $(&apos;#div2&apos;).offsetParent().css(&apos;background&apos;,&apos;green&apos;); //让div2有定位的父级变成绿色，如果没有定位就默认body }); }); &lt;/script&gt; &lt;/head&gt; &lt;body&quot;&gt; &lt;div id=&quot;div1&quot;&gt; &lt;div id=&quot;div2&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;/body&gt; parents(): 获取元素的所有祖先节点。 括号内可以传入需要筛选的元素 parentsUntil(): 获取元素的所有祖先节点。 括号内可以传入需要到截止的元素 示例： &lt;script src=&quot;jquery-1.10.1.min.js&quot;&gt;&lt;/script&gt; &lt;script&gt; $(function(){ $(&apos;#div2&apos;).parents().css(&apos;background&apos;,&apos;red&apos;); //div2的所有父级背景换成红色 $(&apos;#div2&apos;).parents(&apos;#div1&apos;).css(&apos;background&apos;,&apos;red&apos;); //div2的父级只有div1变成红色 $(&apos;#div2&apos;).parents(&apos;body&apos;).css(&apos;background&apos;,&apos;green&apos;); //div2的父级只有body变成绿色 $(&apos;#div2&apos;).parentsUntil(&apos;#div&apos;).css(&apos;background&apos;,&apos;green&apos;); //div2的父级到div1截止变成绿色 }); &lt;/script&gt; &lt;/head&gt; &lt;body&quot;&gt; &lt;div id=&quot;div1&quot;&gt;aaa &lt;div id=&quot;div2&quot;&gt;bbb&lt;/div&gt; &lt;/div&gt; &lt;/body&gt; closest(): 获取元素的最近的祖先节点。（包括元素自身，必须要写参数，并且只能找到一个元素） 示例： &lt;script src=&quot;jquery-1.10.1.min.js&quot;&gt;&lt;/script&gt; &lt;script&gt; $(function(){ $(&apos;#div2&apos;).closest(&apos;.box&apos;).css(&apos;background&apos;,&apos;red&apos;); //通过.box只能找到div1找不到body，因为div1是离div2最近的父级。 //如果元素自身加了class=&quot;box&quot;，那么只会找到它自身 &lt;/script&gt; &lt;/head&gt; &lt;body class=&quot;box&quot;&gt; &lt;div id=&quot;div1&quot; class=&quot;box&quot;&gt;aaa &lt;div id=&quot;div2&quot;&gt;bbb&lt;/div&gt; &lt;/div&gt; &lt;/body&gt; Ps: 实战之王，推荐使用这个。 val(): 获取元素的value值 示例： &lt;script src=&quot;jquery-1.10.1.min.js&quot;&gt;&lt;/script&gt; &lt;script&gt; $(function(){ $(&apos;input&apos;).on(&apos;click&apos;,function(){ alert($(&apos;input&apos;).val()); //弹出input的value值 获取 $(&apos;input&apos;).val(&apos;提交&apos;); //改变input的value值 赋值 }); }); &lt;/script&gt; &lt;/head&gt; &lt;body&quot;&gt; &lt;input type=&quot;button&quot; value=&quot;点击&quot;&gt; &lt;/body&gt; size(): 获取元素的长度 像原生里的length 示例： &lt;script src=&quot;jquery-1.10.1.min.js&quot;&gt;&lt;/script&gt; &lt;script&gt; $(function(){ $(&apos;input&apos;).on(&apos;click&apos;,function(){ alert($(&apos;li&apos;).size()); //获取li的长度 =4 }); }); &lt;/script&gt; &lt;/head&gt; &lt;body&quot;&gt; &lt;input type=&quot;button&quot; value=&quot;点击&quot;&gt; &lt;ul&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/body&gt; each(): 循环，像原生里的for ， each(function(下标，当前操作的元素){}) each()可以添加一个回调函数，函数内可以传两个值，下标和当前操作的元素 示例： &lt;script src=&quot;jquery-1.10.1.min.js&quot;&gt;&lt;/script&gt; &lt;script&gt; $(function(){ $(&apos;li&apos;).each(function(i,li){ $(li).html(i); //给每个li添加内容，内容是下标 if(i==3){ return false; } }) }); &lt;/script&gt; &lt;/head&gt; &lt;body&quot;&gt; &lt;ul&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/body&gt; 关于this ： 在循环中，this在原生JS中是不存在的，只有在事件中才能存在，但是在JQ的each()之中，this是存在的。This相当于括号里第二个参数，指的是元素本身。this等于li。 关于跳出循环： 原生之中，如果要跳出循环，使用的是break。JQ之中跳出循环就不能用break了，要用return false； jQuery方法之事件操作： 事件操作注意: 在JQ中所有的事件操作都是绑定的形式 on(): 执行某事件。 空号里两个参数，第一个表示事件，第二个表示事件执行的函数 可以同时填写多个事件，不用再分开写 并且还可以以JSON的形式，对不同事件执行不同的函数 示例演示： &lt;script src=&quot;jquery-1.10.1.min.js&quot;&gt;&lt;/script&gt; &lt;script&gt; $(function(){ //不同事件执行同一函数 $(&apos;div&apos;).on(&apos;click mouseover&apos;,function(){ alert(123); }) //不同事件执行不同函数 $(&apos;div&apos;).on({ &apos;click&apos; : function(){ alert(123); }, &apos;mouseover&apos; : function(){ alert(456); } }) }) &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div&gt;div&lt;/div&gt; &lt;/body&gt; off(): 关闭某事件。可以全部关闭，也可以只关闭某一件事件 示例演示： &lt;script src=&quot;jquery-1.10.1.min.js&quot;&gt;&lt;/script&gt; &lt;script&gt; $(function(){ $(&apos;div&apos;).on(&apos;click mouseover&apos;,function(){ alert(123); $(&apos;div&apos;).off(); //关闭所有事件 $(&apos;div&apos;).off(&apos;mouseover&apos;); //只关闭mouseover事件 }) }); &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div&gt;div&lt;/div&gt; &lt;/body&gt; delegate()： 事件委托 冒泡机制 $(&apos;ul&apos;).delegate(&apos;li&apos;,&apos;click&apos;,function(){}); undelegate()： 解除事件委托,针对的是dalegate(),不用能off()来解除绑定 示例： &lt;script src=&quot;jquery-3.2.0.js&quot;&gt;&lt;/script&gt; &lt;script&gt; $(function(){ $(&apos;input&apos;).click(function(){ $li = $(&apos;&lt;li&gt;hello&lt;/li&gt;&apos;); //手动创建li $(&apos;ul&apos;).append($li); }) $(&apos;ul&apos;).delegate(&apos;li&apos;,&apos;click&apos;,function(ev){ $(this).css(&apos;background&apos;,&apos;red&apos;); $(&apos;ul&apos;).undelegate(); }) //1.this在事件委托之中，指向的是委托的对象，这里指向的是li //2.如果要找到ul有两种方式： 1) $(‘ul’); 2) ev下有一个对象，ev.delegateTarget 指向的就是ul $(ev.delegateTarget) // $(&apos;li&apos;).click(function(){ // $(this).css(&apos;background&apos;,&apos;red&apos;); // }) // // 通过以上代码可以看出事件绑定的一个优势。 // 1.普通事件在后续添加的li面前是不能执行的，因为在后续添加的li之前，事件操作就已经加载结束了。 // 2.事件绑定可以实现让后续添加的li也拥有事件行为。因为事件是绑定在父级ul身上，只要父级不变，里面元素都不会受影响。 }) &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;ul&gt; &lt;li&gt;11111&lt;/li&gt; &lt;li&gt;11111&lt;/li&gt; &lt;li&gt;11111&lt;/li&gt; &lt;li&gt;11111&lt;/li&gt; &lt;/ul&gt; &lt;input type=&quot;button&quot;&gt; &lt;/body&gt; trigger(): 主动触发，表示页面一刷新就主动触发事件 可以触发自定义事件 示例： &lt;script src=&quot;jquery-1.10.1.min.js&quot;&gt;&lt;/script&gt; &lt;script&gt; $(function(){ $(&apos;div&apos;).click(function(){ alert($(this).html()); }) $(&apos;div&apos;).on(&apos;show&apos;,function(){ alert(123); }) $(&apos;div&apos;).trigger(&apos;click&apos;); //页面一刷新就主动触发事件 $(&apos;div&apos;).trigger(&apos;show&apos;); //可以触发自定义事件 }); &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div&gt;123213&lt;/div&gt; &lt;/body&gt; jQuery方法之事件细解： ev: 等于原声event对象； ev.pageX (相对于整个页面的鼠标位置) ev.clientX (相对于可视区的) 鼠标位置 ev.pageY (相对于整个页面的鼠标位置) ev.clientY (相对于可视区的) 鼠标位置 ev.which: 等于原声event.keyCode，键盘键值。 示例： $(function(){ $(document).keydown(function(ev){ alert(ev.which) //弹出你按下键盘的键值 }) })(); ev.preventDefault: 阻止默认事件 ev.stopPropagetion: 阻止冒泡事件 return false: 阻止冒泡事件 + 阻止默认事件 ev.data: 数据传参 示例： &lt;script src=&quot;jquery-1.10.1.min.js&quot;&gt;&lt;/script&gt; &lt;script&gt; $(function(){ $(&apos;div&apos;).on(&apos;click&apos;,{name:&apos;hello&apos;},function(ev){ alert(ev.data.name); //传入json中name的值 //hello alert(ev.target); //找到当前操作的事件对象是谁 //div alert(ev.type); //找到当前操作的事件是什么类型的事件 //click }) }); &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div&gt;123213&lt;/div&gt; &lt;/body&gt; one(): 事件执行一次 示例： &lt;script src=&quot;jquery-1.10.1.min.js&quot;&gt;&lt;/script&gt; &lt;script&gt; $(function(){ $(&apos;div&apos;).one(&apos;click&apos;,function(){ alert(123); //只能点击弹出一次 }); }); &lt;/script&gt; &lt;/head&gt; &lt;body&quot;&gt; &lt;div id=&quot;login&quot;&gt;&lt;/div&gt; &lt;/body&gt; offset(): 获取元素到屏幕的总距离 示例： &lt;script src=&quot;jquery-1.10.1.min.js&quot;&gt;&lt;/script&gt; &lt;script&gt; $(function(){ $(&apos;#div2&apos;).on(&apos;click&apos;,function(){ alert($(&apos;#div2&apos;).offset().left); //获取元素到屏幕的总距离 }); }); &lt;/script&gt; &lt;/head&gt; &lt;body&quot;&gt; &lt;div id=&quot;div1&quot;&gt; &lt;div id=&quot;div2&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;/body&gt; position(): 获取到有定位的父级的距离.需要把当前元素转化为有定位的形式,因为它不认margin值 示例： &lt;script src=&quot;jquery-1.10.1.min.js&quot;&gt;&lt;/script&gt; &lt;script&gt; $(function(){ $(&apos;#div2&apos;).on(&apos;click&apos;,function(){ alert($(&apos;#div2&apos;).position().left); //获取到有定位的父级的距离. }); }); &lt;/script&gt; &lt;/head&gt; &lt;body&quot;&gt; &lt;div id=&quot;div1&quot;&gt; &lt;div id=&quot;div2&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;/body&gt; offsetParent(): 获取有定位的父级 等于原生JS的offsetParent一样。 示例： &lt;script src=&quot;jquery-1.10.1.min.js&quot;&gt;&lt;/script&gt; &lt;script&gt; $(function(){ $(&apos;#div2&apos;).on(&apos;click&apos;,function(){ $(&apos;#div2&apos;).parent().css(&apos;background&apos;,&apos;green&apos;); //让div2的父级背景变成绿色 $(&apos;#div2&apos;).offsetParent().css(&apos;background&apos;,&apos;green&apos;); //让div2有定位的父级变成绿色，如果没有定位就默认body }); }); &lt;/script&gt; &lt;/head&gt; &lt;body&quot;&gt; &lt;div id=&quot;div1&quot;&gt; &lt;div id=&quot;div2&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;/body&gt; html(): 获取元素标签内的内容 也可以赋值 text(): 获取元素标签内所有标签内的内容,但不包含元素内的标签。 也可以赋值，但是如果赋值标签，也会转化成文本。 get(): 把JQ转化成原声JS 下标和length属性 示例： &lt;script src=&quot;jquery-1.10.1.min.js&quot;&gt;&lt;/script&gt; &lt;script&gt; $(function(){ alert($(&apos;#div1&apos;).get(0).innerHTML); //可以把$(&apos;#div1&apos;)转化成原生document.getElementById(‘div1’）， //实现JQ与JS共存 //get(0)括号里面的数字表示下标 for(var i=0; i&lt;$(&apos;li&apos;).get().length; i++){ //for循环里面可以不带get()，因为JQ文档下有一个属性叫做length $(&apos;li&apos;).get(i).style.background = &apos;red&apos;; //这条程序也可以不用[i]来代替get(i),但是有偷巧的嫌疑，推荐不太熟悉JQ的同学使用标准写法 } }); &lt;/script&gt; &lt;/head&gt; &lt;body&quot;&gt; &lt;div id=&quot;div1&quot;&gt;div1&lt;/div&gt; &lt;ul&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/body&gt; wrap(): 包装 给元素外部添加一个包装 ，传入包装的标签 比如wrap(&apos;&lt;div&gt;&apos;) wrapAll(): 整体包装 把所有元素聚在一起，套上一个整体标签 wrapInner(): 内部包装 给元素内部的内容添加一个包装 unwrap(): 删除元素外部包装 （删除父级，但是不包括body元素） 示例： &lt;script src=&quot;jquery-1.10.1.min.js&quot;&gt;&lt;/script&gt; &lt;script&gt; $(function(){ $(&apos;span&apos;).wrap(&apos;&lt;div&gt;&apos;); //给每个span的外面都套上一个div标签 $(&apos;span&apos;).wrapAll(&apos;&lt;div&gt;&apos;); //把三个span套在一个div标签里面 $(&apos;span&apos;).wrapInner(&apos;&lt;div&gt;&apos;); //给每个span里面的内容套一个div标签 $(&apos;span&apos;).unwrap(&apos;&lt;div&gt;&apos;); //删除了span外面的div标签 }); &lt;/script&gt; &lt;/head&gt; &lt;body class=&quot;box&quot;&gt; &lt;span&gt;span&lt;/span&gt; &lt;span&gt;span&lt;/span&gt; &lt;span&gt;span&lt;/span&gt; &lt;/body&gt; slice(): 截取元素，括号内传入两个参数，参数是元素的下标 第一个参数，开始截取元素的下标位置 第二个参数，结束截取元素的下表位置+1，因为不包括结束截取的元素，所以+1位 示例： &lt;script src=&quot;jquery-1.10.1.min.js&quot;&gt;&lt;/script&gt; &lt;script&gt; $(function(){ $(&apos;li&apos;).slice(1,4).css(&apos;background&apos;,&apos;green&apos;); //截取第1个li到第3个li，让他们的背景变绿 }); &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;ul&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/body&gt; serialize()： 串联化数据 字符串形式 serializeArray()： 串联化数据 数组形式 示例： &lt;script src=&quot;jquery-1.10.1.min.js&quot;&gt;&lt;/script&gt; &lt;script&gt; $(function(){ console.log($(&apos;form&apos;).serialize()); //string : a=1&amp;b=2&amp;c=3 console.log( $(&apos;form&apos;).serializeArray() ); [ { name : &apos;a&apos; , value : &apos;1&apos; }, { name : &apos;b&apos; , value : &apos;2&apos; }, { name : &apos;c&apos; , value : &apos;3&apos; } ] }); &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;form&gt; &lt;input type=&quot;text&quot; name=&quot;a&quot; value=&quot;1&quot;&gt; &lt;input type=&quot;text&quot; name=&quot;b&quot; value=&quot;2&quot;&gt; &lt;input type=&quot;text&quot; name=&quot;c&quot; value=&quot;3&quot;&gt; &lt;/form&gt; &lt;/body&gt; JQ的运动 animate()： 运动方法 可以传参数 第一个参数是个json，里面传入属性和属性值 第二个参数是时间，默认400毫秒，调节运动快慢 第三个参数是运动形式，有两种运动形式（默认swing(慢快慢)，linear(匀速)） 第四个餐宿是回调函数。 stop()： 停止运动 默认阻止当前运动，不会阻止后面的运动 括号里写true，就可以阻止后续所有运动。 元素.stop(true); 括号里如果写两个true，会立即停止到当前运动的目标点，并且停止后续运动 元素.stop(true,ture); finish()： 停止运动 立即停止到你所有运动指定的目标点。 元素.finish(); delay()： 延迟运动，括号传入参数是延迟的时间 示例： $(this).animate({width:300},600).delay(1000).animate({height:300},600); 综合示例： &lt;style&gt; #div1 { width: 100px; height: 100px; background: red; } #div2 { width: 100px; height: 100px; background: red; margin-top: 10px; } &lt;/style&gt; &lt;script src=&quot;jquery-1.10.1.min.js&quot;&gt;&lt;/script&gt; &lt;script&gt; $(function(){ $(&apos;#div1&apos;).click(function(){ $(this).animate({width:300},600).delay(1000).animate({height:300},600); }); $(&apos;#div2&apos;).click(function(){ $(&apos;#div1&apos;).stop(); //默认阻止当前运动，不会阻止后面的运动 $(&apos;#div1&apos;).stop(true); // 停止后续所有运动 $(&apos;#div1&apos;).stop(true,true); // 立即停止到当前运动的目标点，并且停止后续运动 $(&apos;#div1&apos;).finish(); //立即停止到所有运动指定的目标点 }) }); &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;form&gt; &lt;div id=&quot;div1&quot;&gt;&lt;/div&gt; &lt;div id=&quot;div2&quot;&gt;&lt;/div&gt; &lt;/form&gt; &lt;/body&gt; hover(): 鼠标移入移出样式发生改变。hover(function(){},function(){}) 括号里面传入两个函数。 示例： &lt;script src=&quot;jquery-1.10.1.min.js&quot;&gt;&lt;/script&gt; &lt;script&gt; $(function(){ $(&apos;#div1&apos;).hover(function(){ $(&apos;#div1&apos;).css(&apos;background&apos;,&apos;green&apos;); //第一个函数，表示鼠标移入 },function(){ $(&apos;#div1&apos;).css(&apos;background&apos;,&apos;red&apos;); //第二个函数，表示鼠标移出 }); }); &lt;/script&gt; &lt;/head&gt; &lt;body&quot;&gt; &lt;div id=&quot;div1&quot;&gt;&lt;/div&gt; &lt;div id=&quot;div2&quot;&gt;&lt;/div&gt; &lt;/body&gt; hide(): 元素隐藏 （1000）括号内可以传入一个时间参数 以1秒时间的动画过度隐藏 show(): 元素显示 （1000）括号内可以传入一个时间参数 以1秒时间的动画过度显示 示例： &lt;script src=&quot;jquery-1.10.1.min.js&quot;&gt;&lt;/script&gt; &lt;script&gt; $(function(){ $(&apos;#div1&apos;).hover(function(){ $(&apos;#div2&apos;).hide(1000); //移入div1的时候，div2隐藏 },function(){ $(&apos;#div2&apos;).show(1000); //移出div1的时候，div2显示 }); }); &lt;/script&gt; &lt;/head&gt; &lt;body&quot;&gt; &lt;div id=&quot;div1&quot;&gt;&lt;/div&gt; &lt;div id=&quot;div2&quot;&gt;&lt;/div&gt; &lt;/body&gt; fadeIn(): 元素淡入 （1000）括号内可以传入一个时间参数 以1秒时间的动画过度淡入效果 fadeOut(): 元素淡出 （1000）括号内可以传入一个时间参数 以1秒时间的动画过度淡出效果 Ps：默认时间是400毫秒。 示例： &lt;script src=&quot;jquery-1.10.1.min.js&quot;&gt;&lt;/script&gt; &lt;script&gt; $(function(){ $(&apos;#div1&apos;).hover(function(){ $(&apos;#div2&apos;).fadeOut(1000); //移入div1的时候，div2淡出 },function(){ $(&apos;#div2&apos;).fadeIn(1000); //移出div1的时候，div2淡入 }); }); &lt;/script&gt; &lt;/head&gt; &lt;body&quot;&gt; &lt;div id=&quot;div1&quot;&gt;&lt;/div&gt; &lt;div id=&quot;div2&quot;&gt;&lt;/div&gt; &lt;/body&gt; fadeTo(): 元素淡入淡出 括号里面传入两个值，第一个值传入时间，第二个值传入透明度数值。 示例： &lt;script src=&quot;jquery-1.10.1.min.js&quot;&gt;&lt;/script&gt; &lt;script&gt; $(function(){ $(&apos;#div1&apos;).hover(function(){ $(&apos;#div2&apos;).fadeTo(1000,0.3); //移入div1的时候，div2以1秒的时间降透明度变成0.3 },function(){ $(&apos;#div2&apos;).fadeTo(2000,1); //移出div1的时候，div2以2秒的时间降透明度变成1 }); }); &lt;/script&gt; &lt;/head&gt; &lt;body&quot;&gt; &lt;div id=&quot;div1&quot;&gt;&lt;/div&gt; &lt;div id=&quot;div2&quot;&gt;&lt;/div&gt; &lt;/body&gt; slideDown(): 元素向下展开 （1000）括号内可以传入一个时间参数 ，以1秒时间的动画过度向下展开效果 slideUp(): 元素向上卷入 （1000）括号内可以传入一个时间参数 ，以1秒时间的动画过度向上卷入效果 Ps：默认时间是400毫秒。 示例： &lt;script src=&quot;jquery-1.10.1.min.js&quot;&gt;&lt;/script&gt; &lt;script&gt; $(function(){ $(&apos;#div1&apos;).hover(function(){ $(&apos;#div2&apos;).slideUp(1000); //移入div1的时候，div2向上卷入 },function(){ $(&apos;#div2&apos;).slideDown(3000); //移出div1的时候，div2向下展开 }); }); &lt;/script&gt; &lt;/head&gt; &lt;body&quot;&gt; &lt;div id=&quot;div1&quot;&gt;&lt;/div&gt; &lt;div id=&quot;div2&quot;&gt;&lt;/div&gt; &lt;/body&gt; $下的常用方法 $.type(): 判断元素的类型 和typeof一样，但比他更强大，可判断的类型更细致更多 $.trim(): 去除文本的前后空格 示例： $(function(){ var str = &apos; hello &apos;; alert(&apos;(&apos;+str+&apos;)&apos;); //弹出str的内容是带空格的。 alert(&apos;(&apos;+str.trim()+&apos;)&apos;); //弹出str的内容是去除空格的。 }); $.inArray(): 类似于indexOf，不过是返回数组的下标位置。 括号内传入两个值，第一个是你要查找的数组内容，第二个参数是数组的名称 示例： $(function(){ var arr = [&apos;a&apos;,&apos;b&apos;,&apos;d&apos;,&apos;d&apos;]; alert($.inArray(&apos;b&apos;,arr)); //弹出b在数组的位置 }); $.proxy(): 改变this指向 括号传入两个参数，第一个是函数的名称，第二个是需要指向谁的名称。 如果要调用函数，需要在后面加上(); 示例： $(function(){ function show(a,b){ alert(a+&apos;:&apos;+b) alert(this); } //show(); //这里的this指向是window //$.proxy(show,document)(); //这里的this指向是document。 //$.proxy(show,document)(3,4); //传参的参数可以写在后面的括号里 //$.proxy(show,document,3,4)(); //参数也可以写在开始的括号里，第三位开始可以接受参数 $.proxy(show,document,3)(4); //参数还可以混着写 }); $.noConflict(): 防止$冲突 ，可以用其他单词符号替换$的作用 示例： var miaov = $.noConflict(); //用此方法可以直接用miaov代替$在JQ中的作用 miaov(function(){ miaov(&apos;body&apos;).css(&apos;background&apos;,&apos;red&apos;); }) $.parseJSON(): 把字符串转变成JSON 这个字符串必须是严格模式下的JSON 示例： var str = &apos;{&quot;name&quot;:&quot;miaov&quot;}&apos; //必须写成这样的严格模式。 alert($.parseJSON(str).name); //这样就可以把字符串转成可以使用的JSON $.makeArray(): 把类数组变成真正的数组 类数组：一种有长度和下标的元素叫做类数组 示例： var aDiv = document.getElementsByTagName(&apos;div&apos;); //这种有长度和下标的元素叫做类数组 //aDiv.push(); //错误的写法，必须通过下面的方法转成数组 $.makeArray(aDiv).push(); //通过此方法可以变成真正的数组，不会报错 JQ的Ajax使用 $.ajax(): JQ下的ajax使用方法 $.ajax({ url : &apos;xxx.php&apos;, //地址 data : &apos;name=hello&amp;age=20&apos;, //数据 type : &apos;POST&apos;, //数据传输方式 success : function(data){ //成功之后执行的参数 alert(1); }, error : function(){ //失败之后执行的参数 alert(2); } contentType //请求头信息，post请求的时候需要写一下 dataType //返回的数据类型 cache //是否缓存 Timeout //是否延迟 }) $.get(): JQ下的ajax的细分方法，get方式，可传两个参数 第一个参数是url地址，如果需要传值可在url后面添加？+你要传的值 第二个参数是你成功后的回调函数。 示例： $.get(‘url?+你要的传的值’function(){}); //两种传数据的方式 $.get(‘url’,{name:’hello’},function(){}); $.post(): JQ下的ajax的细分方法，post方式 示例：$.post(‘url’,function(){});]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[JS正则表达式]]></title>
      <url>%2F2017%2F04%2F08%2FJS%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%2F</url>
      <content type="text"><![CDATA[正则 ： 也叫做规则，让计算机读懂人类的规则。 PS：正则都是操作字符串的; 简写形式： var re = /a/; 大部分情况下推荐简写。因双斜杠//会造成浏览器识别成注释，所以做斜杠之间添加一个a。 全写形式： var re = new RegExp(‘a’); 特殊情况下需要写全写。比如在传参的情况下，就必须写全写方式 常规正则例子 匹配中文：[\u4e00-\u9fa5] 行首行尾空格：^\s |\s$ Email：^\w+@[a-z0-9]+(\.[a-z]+){1,3}$ 网址：[a-zA-z]+://[^\s]* QQ号：[1-9]\d{4,9}$ 邮政编码：^[1-9]\d{5}$ 身份证：[1-9]\d{14}|[1-9]\d{17}|[1-9]\d{16}x 正则表达式常用方法： test方法 test方法能做什么 : 正则去匹配字符串，如果匹配成功就返回真，如果匹配失败就返回假。 test的写法： 正则.test(字符串); 示例： var str = ‘abcdef’; var re = /b/; //通过b去匹配字符串中的字符。如果含有b，就返回布尔值true/否则返回false alert(re.test(str)); //true 转义字符： 字符前面加反斜杠\，会转义字符。 \s : 空格; \S : 非空格; \d：数字; \D：非数字; \w：字符(字母，数字，下划线_); \W：非字符; 示例： 通过\D来判断，非数字是为真，弹出 ’不全是数字’；没有非数字的时候弹出 ‘全是数字’； var str = ‘56464t46464’; var re = /\D/; if( re.test(str) ){ alert(‘不全是数字’); } else{ alert( ‘全是数字’ ) } search方法 search方法能做什么 : 正则去匹配字符串，如果匹配成功就返回匹配成功的位置，如果匹配失败就返回-1。 search的写法： 字符串.search(正则); 示例： var str = ‘abcdef’; var re = /B/i; //通过b去匹配字符串中的字符。如果含有b，就返回b的位置/否则返回-1 alert( tr.search(re) ); // 1 正则默认： 正则默认下是区分大小写; 如果不区分大小写的话，需要在正则的最后加标识符 i (不区分大小写) 示例： var re = /B/i; //表示不区分大小写。 var re = new RegExp(‘B’,’i’); //不区分大小，全写下的写法。 match方法 match方法能做什么 : 正则去匹配字符串，如果匹配成功就返回匹配成功的数组，如果匹配失败就返回null。 match的写法： 字符串.match(正则); 示例： var str = ‘ab123c45de678f54fd9’; var re = /\d+/g; //通过/d数字去匹配字符串中的字符。如果含有数字，就返回数组 alert( str.match(re) ); //1,2,3,4,5,6,7,8,9 正则默认： 正则匹配成功就会结束，不会继续匹配。 如果想全部查找，就要加标识符 g (全局匹配) 示例： var re = /\d+/g; //表示走完整个字符串。 var re = new RegExp(‘\d+’,’g’); 量词 ‘+’ : + 表示至少出现一次(&gt;=1)， 可以匹配不确定的位置。 示例： var str = ‘ab123c45de678f54fd9’; var re = /\d+/g; alert( str.match(re) ); //123，45，678，9 replace方法 replace方法能做什么 : 正则去匹配字符串，匹配成功的字符去替换成新的字符串，如果匹配失败就返回null。 replace的写法： 字符串.replace(正则, 新的字符串); replace的第二个参数：可以是字符串，也可以是一个回调函数。 示例： var str = ‘aaa’; alert( str.replace(/a/,’b’) ); //弹出baa; 通过a去匹配字符串中的字符。如果含有a，就替换成b alert( str.replace(/a/g,’b’) ); //弹出bbb; alert( str.replace(/a+/g,’b’) ); //弹出b; |: 正则中表示‘或’的意思。 示例： &lt;script&gt; window.onload = function(){ var aT = document.getElementsByTagName(&apos;textarea&apos;); var oBtn = document.getElementById(&apos;btn&apos;); var re = /大众|技术|特色|越骂越火/g; oBtn.onclick=function(){ aT[1].value = aT[0].value.replace(re,function(str){ //函数的第一个参数str，就是匹配成果的字符 var result = &apos;&apos;; for(var i=0; i&lt;str.length; i++){ result += &apos;*&apos;; } return result; }); } } &lt;/script&gt; &lt;/head&gt; &lt;body&gt; 替换前&lt;/br&gt; &lt;textarea name=&quot;&quot; id=&quot;&quot; cols=&quot;30&quot; rows=&quot;10&quot;&gt;&lt;/textarea&gt;&lt;/br&gt; 替换后&lt;/br&gt; &lt;textarea name=&quot;&quot; id=&quot;&quot; cols=&quot;30&quot; rows=&quot;10&quot;&gt;&lt;/textarea&gt;&lt;/br&gt; &lt;input type=&quot;button&quot; id=&quot;btn&quot; value=&quot;确定&quot;&gt; &lt;/body&gt;* 正则表达式中的小括号 匹配子项 : 小括号(); ()还有另外一种意思，分组操作。 把正则的整体叫做《母亲》， 然后把左边第一个小括号里面的正则，叫做第一个子项(母亲的第一个孩子) 示例： var str = &apos;2013-6-7&apos; var re = /(\d+)(-)/g; str = str.replace(re,function($0,$1,$2){ //第一个参数：$0(母亲), 第二个参数:$1(第一个子项), 第二个参数：$2(第二个子项) return $1 + &apos;.&apos;; //不用指向的方法return $0.substring(0,$0.length-1) + &apos;.&apos;; }) alert(str); //通过匹配指向，把str 变成了 2013.6.7 match指向方法 示例： var str = ‘abc’; Var re = /(a)(b)(c)/; alert( str.match(re) ) ; //[abc,a,b,c] 当match不加g的时候才可以获取到子项的集合 正则表达式中的字符类 字符类 : 用[]中括号来表示。一组相似的元素。 []的整体代表一个字符。 []里面的内容是或者关系。 示例： var str = ‘abc’; var re = /a[bde]c/; //[]里面的内容是或者关系，只代表一个字符 alert(re.test(str)); //true 排除 : ^ 如果^写在[]里面的话，就表示排除的意思。 和JS中的！差不多意思，都是表示 非 的意思。 如果写在正则的最开始位置，就代表起始的意思 示例： var str = ‘abc’; var re = /a[^bde]c/; //如果str中第二位不是中括号里都内容，那么返回真。 alert(re.test(str)); // false 意思是必须排除掉中括号里面的内容才是真。 范围 : - 如果-写在[]里面的话，就表示范围的意思。写法是必须从小到大。 示例： var str = ‘abc’; var re = /a[a-z]c/; //如果str中第二位是中括号里都范围，那么返回真。 var re=/a[a-z0-9A-Z]+c/; //如果要增大范围，需要在中括号后面添加一个‘+’； //意思是从a到做，0到9，A到Z之间的范围 alert(re.test(str)); //意思是从a到z中间任意一个字母能匹配到b，就返回真。 案例：过滤标签 script&gt; window.onload = function(){ var aT = document.getElementsByTagName(&apos;textarea&apos;); var oInput = document.getElementById(&apos;input1&apos;); 方法1 var re = /&lt;[^&gt;]+&gt;/g; //匹配只要不是&gt;的都可以 方法2 var re = /[\w\W]+/g; //匹配所有字符或非字符 oInput.onclick = function(){ aT[1].value = aT[0].value.replace(re,&apos;&apos;); }; }; &lt;/script&gt; &lt;/head&gt; &lt;body&gt; 替换前&lt;br /&gt; &lt;textarea&gt;&lt;/textarea&gt;&lt;br /&gt; 替换后&lt;br /&gt; &lt;textarea&gt;&lt;/textarea&gt;&lt;br /&gt; &lt;input type=&quot;button&quot; value=&quot;确定&quot; id=&quot;input1&quot; /&gt; &lt;/body&gt; 转义字符 转义字符： 字符前面加反斜杠\，会转义字符。 \s: 空格; \S: 非空格; \d：数字; \D：非数字; \w：字符(字母，数字，下划线_); \W：非字符; . : 任意字符; . : 代表真正的点; 示例： var str = &apos;a.c&apos;; var re = /a\.c/; //a和c中间的 \. 代表只能匹配点 . ; alert(re.test(str)); \b : 独立的部分 （ 起始，结束，空格 ） \B : 非独立的部分 var str = &apos;onetwo&apos;; var re = /one\b/; //不是结束的位置，返回false var re = /\bone/; //起始的位置，返回true alert( re.test(str) ); 案例：利用正则获取class window.onload = function(){ var aLi = getByClass(document,&apos;box1&apos;); for(var i=0;i&lt;aLi.length;i++){ aLi[i].style.background = &apos;red&apos;; } 利用非正则的方法 /*function getByClass(oParent,sClass){ var arr = []; var aEle = oParent.getElementsByTagName(&apos;*&apos;); for(var i=0;i&lt;aEle.length;i++){ if( aEle[i].className == sClass ){ arr.push( aEle[i] ); } } return arr; }*/ 使用正则的方法 function getByClass(oParent,sClass){ var arr = []; var aEle = oParent.getElementsByTagName(&apos;*&apos;); //var re = /sClass/; //当正则需要传参的时候，一定要用全称的写法 var re = new RegExp(&apos;\\b&apos;+sClass+&apos;\\b&apos;); for(var i=0;i&lt;aEle.length;i++){ if( re.test(aEle[i].className) ){ arr.push( aEle[i] ); } } return arr; } }; &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;ul&gt; &lt;li class=&quot;box1&quot;&gt;111&lt;/li&gt; &lt;li&gt;111&lt;/li&gt; &lt;li class=&quot;box1box2&quot;&gt;111&lt;/li&gt; &lt;li&gt;111&lt;/li&gt; &lt;li class=&quot;box1 box2&quot;&gt;111&lt;/li&gt; &lt;/ul&gt; &lt;/body&gt; 重复的子项 \1 : 重复的第一个子项 ，1这个数字就代表重复的第几个子项 示例： var str = &apos;abca&apos;; var re = /(a)(b)(c)\2/; //这里的\2表示重复第二个子项，但是\2的位置对应的是a,所以返回的是false alert( re.test(str) ); var re = /\w\w/; c9 var re = /(\w)\1/; cc 99 //由于\1是重复第一个子项，所以它匹配的是对应第一个子项通向的字符，比如 cc 99 这样两个相同的字符才能匹配成功。 案例：查找字符串中重复最多的字符 var str = ‘assssjdssskssalsssdkjsssdss’; var arr = str.split(‘’); str = arr.sort().join(‘’); var value = ‘’; var index = 0; var re = /(\w)\1+/g; str.replace(re,function($0,$1){ if(index&lt;$0.length){ index = $0.length; value = $1; } }); alert(‘最多的字符:’+value+’,重复的次数:’+index); 量词 量词 ： 正则中是用大括号来书写的 {} {4,7} : 意思是最少出现4次，最多出现7次 {4，} ： 意思是最少出现4次，最大无限 {4} ： 意思是正好出现4次 + : {1,} 至少出现1次 ? : {0,1} 出现0次或者1次 * : {0,} 至少出现0次 + 和 * 有一定的区别，+ 必须出现至少1次，而* 可以一次也不用出现 示例： var str = &apos;ab&apos;; var re = /ab+/; alert(re.test(str)); //返回真，但是如果str = &apos;ac&apos;; 呢，就会返回假 我们再来看 var str = &apos;ac&apos;; var re = /ab*/; alert(re.test(str)); //返回真 从上面的例子可以看出来，如果我们把b后面的 + 号换成 * 号，就可以返回true。 ^ : 写在正则的最开始位置，就代表起始的意思 $ : 写在正则的最后位置 , 就代表结束的意思 案例： 判断是不是QQ号 window.onload = function(){ var aInput = document.getElementsByTagName(&apos;input&apos;); var re = /^[1-9]\d{4,11}$/; aInput[1].onclick = function(){ if( re.test(aInput[0].value) ){ alert(&apos;是QQ号&apos;); } else{ alert(&apos;不是QQ号&apos;); } }; }; &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;input type=&quot;text&quot; /&gt;&lt;input type=&quot;button&quot; value=&quot;确定&quot; /&gt; &lt;/body&gt; 案例：去除前后空格 var str = &apos; hello &apos;; alert( &apos;(&apos;+trim(str)+&apos;)&apos; ); function trim(str){ var re = /^\s+|\s+$/g; return str.replace(re,&apos;&apos;); }]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[JS原创知识类点]]></title>
      <url>%2F2017%2F04%2F08%2FJS%E7%9A%84%E4%B8%80%E4%BA%9B%E7%9F%A5%E8%AF%86%E7%B1%BB%E7%82%B9%2F</url>
      <content type="text"><![CDATA[记录JS常用的一些知识点，比如闭包，DOM优化，枚举算法，快速排序。。。的相关知识 个人笔记，仅供参考 闭包 什么是闭包？ 概念： 1. 函数嵌套函数 2. 内部函数可以引用外部函数的参数或者是变量 3. 函数和变量不会被垃圾回收机制所收回。 案例1 function aaa(a){ var b = 5; function bbb(){ alert(a); //bbb()函数可以访问变量a alert(b); } } aaa(); aaa函数执行完毕之后，函数中的变量a和变量b都是不会被垃圾回收机制回收的，因为变量a和变量b都还在bbb函数中被引用着。 案例2 function aaa(){ var a = 5; function bbb(){ alert(a); } return bbb; } var c = aaa(); //在这里aaa的函数已经被执行 c(); //c这里代表的是bbb函数，c执行的话，其实是执行的bbb函数，也就是说bbb函数并没有被垃圾回收机制收回。 垃圾回收机制 function aaa(){ var a = 1; } aaa(); 当aaa()函数被执行过之后，函数内的变量a就会被垃圾回收机制所收回，所以变量a就不会存在了。JS中为了节省内存，所以它是这样设计的。 闭包有什么好处？引用在哪里？ 好处 1. 希望一个变量长期驻扎在内存当中。 案例3 var a = 1; function aaa(){ a++; alert(a); } aaa(); //2 aaa(); //3 alert(a); //1 每调用aaa()一次，a就会被累加一次 这的a是全局变量，变量a在函数内部被引用累加，函数外部丝毫不受影响。 但是为了节约内存，我们应该尽量避免使用全局变量 案例3 function aaa(){ var a = 1; a++; alert(a); } aaa(); //2 aaa(); //2 每调用aaa()一次，a就会被重新定义赋值等于1，然后被累加一次。 有没有办法可以做到，既让变量a是局部变量，又可以让它累加呢？ 通过闭包我们可以做到。 2. 避免全局变量的污染。 案例3 function aaa(){ var a = 1; return function (){ a++; alert(a); } } var b = aaa(); //把aaa赋给变量b b(); //2 变量b调用的其实是aaa的内部函数 b(); //3 alert(a); //报错 变量a不存在，所以说a是局部变量 在这种情况下，就构成了一个函数嵌套函数的关系，变量a相对于在内部函数中是可以被找到的，而且它又不受外部函数执行完毕的影响。所以说当aaa()执行完毕的时候，这个内部函数依然可以调用到a的变量，而且每次调用的时候还能将它累加。 这样写显得比较麻烦，我们用函数表达式的方式重新写一遍。 3. 私有成员的存在 案例4 var aaa = function(){ var a = 1; return function (){ a++; alert(a); } } aaa(); //2 aaa(); //3 和案例3一样的效果，我们通常把这种方法叫做代码模块化。而变量a已经变成函数的私有成员。 用法 1. 模块化代码 案例5 var aaa = (function(){ var a = 1; function bbb(){ a++; alert(a); } function ccc(){ a++; alert(a); } return { b:bbb, c:ccc } })(); aaa.b(); //2 aaa.c(); //3 alert(a); //报错 ，调用不到 alert(bbb); //报错 ，调用不到 alert(ccc); //报错 ，调用不到 这样写，变量a就变成了aaa的私有成员，而函数bbb和函数ccc就变成了aaa的私有方法。 2. 在循环中直接找到对应元素的索引 案例6 &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script&gt; window.onload = function(){ var aLi = document.getElementsByTagName(&apos;li&apos;); for(var i=0; i&lt;aLi.length; i++){ 第一种写法： (function(i){ aLi[i].onclick = function() { alert(i); } })(i); 第二种写法： aLi[i].onclick = (function(i) { return function () { alert(i); } })(i); } } &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;ul&gt; &lt;li&gt;11111111&lt;/li&gt; &lt;li&gt;222222&lt;/li&gt; &lt;li&gt;3333&lt;/li&gt; &lt;/ul&gt; &lt;/body&gt; &lt;/html&gt; 通过上面的闭包写法可以将索引值直接传入进去，而不用在给元素加索引。 闭包需要注意的地方？ 在IE下有可能会引发内存泄漏 当页面跳转的时候，变量不会被释放，会一直存在于内存之中，使你的CPU内存累加，只有在关闭浏览器的情况下，才会释放这个内存。这就是内存泄漏。 案例7 &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script&gt; window.onload = function(){ var oDiv = document.getElementById(&apos;div1&apos;); oDiv.onclick = function(){ alert(oDiv.id); } 这种情况下会造成IE6下的内存泄漏 解决办法一 window.onunload = function(){ oDiv.onclick = null; } 解决办法二 var id = oDiv.id; oDiv.onclick = function(){ alert(id); } oDiv = null; } &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;div1&quot;&gt;11111&lt;/div&gt; &lt;/body&gt; &lt;/html&gt; 满足内存泄漏的条件： 当一个是由获取DOM节点或数组对象的变量，它的一个属性去引用一个内部函数，而函数内部的这个变量又去引用外部的对象的时候，就会发生内存泄漏。 而闭包是不会造成内存泄漏，造成内存泄漏的原因是浏览器的BUG。 函数声明和函数表达式 函数声明： function aaa() {} 函数表达式： function 函数名（可写可不写）() {} 写函数名：命名函数表达式； 不写函数名：匿名函数表达式； var a=function aaa() {} : 命名函数表达式 var a=function() {} : 匿名函数表达式 (function(){}); ~function aaa(){} -function aaa(){} +function aaa(){} !function aaa(){} 函数声明与函数表达式的区别： 1. 函数表达式可以直接在后面加括号执行。而函数声明会报错 例1. function aaa() { alert(1); }(); //函数声明不会执行，报错 例2. var a = function aaa() { alert(1); }(); //表达式能执行。 2. 函数声明预解析，函数声明可以提前被解析出来的。 例3. if(true){ function aaa() { alert(1); } } else{ Function aaa() { alert(2); } } aaa(); 因为函数声明会被预解析，所以if判断是发生在函数执行完之后，判断不会执行。 在不同浏览器下会有不同的结果。 执行结果：火狐弹出1，IE弹出2. 例4. if(true){ var a = function aaa() { alert(1); } } else{ var a = function aaa() { alert(2); } } a(); 函数表达式会在判断后执行。 执行结果：火狐弹出1，IE弹出1. 结论： 所以说写程序的过程中，在写语句的时候，如果要执行不同的函数，一定不要用函数声明，一定要使用函数表达式。 例5： var a = function aaa() { alert(1); } a(); //表达式在任何浏览器下都是没有问题的。 aaa(); //不规范，表达式内部的命名函数在外部是找寻不到的，标准浏览器是不允许执行这种函数的。 //执行结果：火狐下回报错。 非标准IE下会弹出1. 原因是：IE8以下会解析错误，会解析成a(); 和aaa();两个函数。 例6： var a = function aaa() { alert(1); alert( typeof aaa ); //在函数内部是可以被调用到的。 } a(); 结论： 在写函数表达式的时候，尽量不要写有名函数表达式。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[ECMAScript6]]></title>
      <url>%2F2017%2F04%2F08%2FECMAScript6%2F</url>
      <content type="text"><![CDATA[ECMAScript 6.0（以下简称 ES6）是 JavaScript 语言的下一代标准，已经在2015年6月正式发布了。它的目标，是使得 JavaScript 语言可以用来编写复杂的大型应用程序，成为企业级开发语言。 作者：阮一峰的博客地址 点击打开]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[数组、字符串、时间方法]]></title>
      <url>%2F2017%2F04%2F07%2FJS%E5%88%9D%E7%BA%A7%2F</url>
      <content type="text"><![CDATA[JS很初级的东西，放进博客是为了方便自己忘了的时候查阅。 字符串获取类，封装检测数字的方法 charCodeAt() 获取某个字符串的计算机编码。 0-9 a-z A-Z fromCharCode() 根据计算机编码返回字符串。 charAt(num) 根据num数字可以获取到num位置的字符串。 indexOf(‘str’) 根据string字符串中的某个字符，可以获取到它在string中的第几个位置. IndexOf(),从左往右。 lastindexOf(),从右往左。 例：var str=’www.miaov.com/2013’; alert(str.indexOf(‘m’)); 弹出4； 如果想查找m后面的m是多少位，比如在m，后面键入一个m位置+1的数字。 例如m是第4位。所以应该在后面写5. 例：alert(str.indexOf(‘m’,5)); 弹出12. substring() 根据数字来选择截取的位置。 例：str = ‘妙味课堂是一支独具特色的IT培训团队’； alert(str.substring(4));从第四位开始数，弹出‘是一支独具特色的IT培训团队’; alert(str.substring(0,2)); 从0位开始读，到第2位截止。弹出‘妙味’两个字。 alert(str.substring(2,0));默认从零开始，如果第一位比第二位大，则自动调转成0,2。弹出同上。 alert(str.substring(-3,2));默认负数当着0处理。弹出同上。 slice() 同substring()；一样根据数字来选择截取的位置。但有一定的区别。 例：alert(str.slice(0,2));和substring一样，弹出‘妙味’连个字； alert(str.slice(2,0));这里开始出现区别，弹出空的； alert(str.slice(-4,-2));负数从后倒着数。弹出‘培训’两个字。 toUpperCase() 将英文字母转换成大写 toLowerCase() 将英文字母转成小写。 split() 把字符串拆分成数组。 例： var str=’www.miaov.com’; var str1=’leo’; alert(str.split(‘.’));//[‘www’,’miaov’,’com’]加上‘.’，就是以.作为分隔符。 alert(str1.split()); //[‘leo’];括号不加东西，就是分割成一个整体 alert(str1.split(‘’)); //[‘l’,’e’,’o’] 加个空字符串，能把单个字母分开 var str2=’2014-09-11-23-11’ alert(str2.split(‘-‘,3));//[‘2014’,’09’,’11’]后面放的数字，表示第3位开始没有了。 jion(); 将数组转换成字符串。 Var arr=[‘aa’,’bb’,’cc’]; alert(arr.jion()); //’aa,bb,cc’; alert(arr.jion(‘’)); //’aabbcc’;将逗号转换成了空字符串 alert(arr.jion(‘-‘)); //’aaq-bb-cc’; 数组的方法 arr = [‘TM’,’钟意’,’张森’,’杜鹏’]; arr.push() 往数组后面插入内容。 alert(arr.push(‘abc’))返回值是数组的长度4. arr.unshift() 往数组前面插入内容。返回值同样是数组的长度，但是不支持IE6,7。 arr.pop() 删除数组最后一个。返回值是最后被删除的那个内容。 arr.shift() 删除数组最前面的一个。返回值同样是最前面被删除的那个内容。 例；arr.unshift(arr.pop());把数组最后一个放到数组最前面。 arr.splice(0,1) 从数组第0个开始删除，删除1个。返回值是删除的内容。《删除》 arr,splice(0,1,’莫涛’) :删除第0个，然后替换成‘莫涛’。《替换》 arr.splice(1,0,’钟意媳妇儿’) : 在数组第0个后面，第一个前面，添加内容。 《添加》 arr.sort() 数组排序。默认情况下根据‘字符串’在计算中的编码进行从小到大的排序。 arr.sort(function(a,b){ //sort比较函数，排数字。 Return a-b; 从小到大排序； return a-b; // return b-a; 从大到小排序。 }); arr.sort(function(a,b){ //随机排序，Math.random()，返回值是从0到1中间随机的一个数值。 return Math.random()-0.5; //运用这个原理可以做到随机排序。 }); Math.random() 随机数及随机公式推理 Math.random(); 从0到1，随机返回0到1之间的任意一个小数。 Math.round(); 四舍五入,Math.round(Math.random());通过此方法可以随机的返回0或1。 Math.round(Math.random()*10); 随机返回1到10之间的任何一个整数。 以此推出公式： 从x到y之间的值 Math.round(Math.random()*(y-x)+x);随机返回x到y之间任何一个整数。 从0到x之间的一个值： Math.round(Math.random()*x);随机返回一个0&lt;=x的整数。 Math.ceil() 向上取整。 从1到X之间的一个值。Math.ceil(Math.random()*x) 随机返回一个&gt;=1或&lt;=x的整数。 Math.floor() 向下取整，与Math.ceil相反。 Math.pow() 平方，立方。 Math.pow(3,2); 3的平方。Math.pow(9,1/3)：9的开立方 Math.sqrt() 开平方，括号传入一个数字，就是这个数字的开方 Math.max() 两个值取其大值 Math.max(2,1)； 返回其中一个比较大的值 concat() 把数组复制出来，然后连接一起，形成一个新的数组。 例：arr=[1,2,3];arr1=[4,5,6];arr2=[7,8,9]; arr.concat(arr1); 两个数组连接在一起。 arr.concat(arr1,arr2);三个数组连接在一起。 reverse(); 把数组里的内容颠倒。 例：arr=[1,2,3]; arr.revarse() alert(arr);弹出[3,2,1]; 系统时间对象 var myTime = new Date(); 获取系统时间 var iYear = my Time.getFullYear(); 获取年 var iMonth = myTime.getMonth(); 获取月 //月份是从零开始算的，如果要得到一个正常的需要+1 var iDate = myTime.getDate(); 获取日 var iWeek = myTime.getDay(); 获取星期 var iHours = myTime.getHours(); 获取几点 var iMin = myTime.getMinutes(); 获取几分 var iSec = myTime.getSeconds(); 获取几秒 未来时间 通过new Data(),在括号内传入未来的时间，数字形式需要注意月需要-1 数字形式： new Data(2013.04.1.9.48.12); 字符串形式： new Data(‘June 10,2013 12:13:14’); Math.floor();向下取整。Var t=Math.floor((iNew-iNow)/1000); 天：Math.floor(t/86400); 时：Math.floor(t%86400/3600);多少天多少小时 分：Math.floor(t%3600/60); 秒：Math.floor(t%60); getTime() new Data().getTime(); 方法可返回距 1970 年 1 月 1 日之间的毫秒数。 setTime(); 使用 setTime() 向 1970/01/01 添加毫秒，并显示新的日期和时间。 // 将当前时间换成时间格式字符串 var timestamp3 = 1403058804; var newDate = new Date(); newDate.setTime(timestamp3 * 1000); // Wed Jun 18 2014 console.log(newDate.toDateString()); // Wed, 18 Jun 2014 02:33:24 GMT console.log(newDate.toGMTString()); // 2014-06-18T02:33:24.000Z console.log(newDate.toISOString()); // 2014-06-18T02:33:24.000Z console.log(newDate.toJSON()); // 2014年6月18日 console.log(newDate.toLocaleDateString()); // 2014年6月18日 上午10:33:24 console.log(newDate.toLocaleString()); // 上午10:33:24 console.log(newDate.toLocaleTimeString()); // Wed Jun 18 2014 10:33:24 GMT+0800 (中国标准时间) console.log(newDate.toString()); // 10:33:24 GMT+0800 (中国标准时间) console.log(newDate.toTimeString()); // Wed, 18 Jun 2014 02:33:24 GMT console.log(newDate.toUTCString()); 西方月份单词：January,February,March,April,May,June,July,August,September,October,November,December;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[图片预加载]]></title>
      <url>%2F2017%2F04%2F07%2F%E5%9B%BE%E7%89%87%E9%A2%84%E5%8A%A0%E8%BD%BD%2F</url>
      <content type="text"><![CDATA[当用户打开一个有很多图片的大网站的时候，这么多图片如果要加载完再观看，会让用户的浏览体验不好。有没有一种方法可以在页面刚打开的时候，去加载第一张图片，然后页面加载完了以后，在用户看的时间内去加载后面的内容。 又或者用户再看到前面几张图片的时候就点开或者离开，如果这时候浏览器还把后面所有的图片都加载完，就会造成极大的资源浪费。 通过这篇文章可以解决掉上面的问题，实现图片预加载或按需加载 要做到图片预加载，需要一个工具 -&gt; Image对象 Image对象 var oImage = new Image(); oImage.src = &apos;&apos;; 属性 ： scr :当我们给Image对象的src属性赋值一个url的时候，这个Image对象就会去加载url资源，加载完成以后的资源被保存到了浏览器的缓存文件夹里面，下次如果我们要去调用这个url地址的时候，直接从缓存文件夹读取到的，所以速度很快，并且还可以节约资源。 onload事件 当资源加载完成的时候触发 onerror事件 当资源加载失败的时候触发 案例1，图片预加载 &lt;!DOCTYPE HTML&gt; &lt;html&gt; &lt;head&gt; &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot;&gt; &lt;title&gt;无标题文档&lt;/title&gt; &lt;script&gt; window.onload = function() { var oImg = document.getElementById(&apos;img1&apos;); var oImage = new Image(); var arr = [ &apos;http://d.hiphotos.baidu.com/image/w%3D2048/sign=2846dc1369600c33f079d9c82e74500f/a044ad345982b2b7938726c333adcbef76099b98.jpg&apos;, &apos;http://f.hiphotos.baidu.com/image/w%3D2048/sign=2da141ad013b5bb5bed727fe02ebd439/7dd98d1001e9390124aacd3879ec54e736d1960f.jpg&apos;, &apos;http://g.hiphotos.baidu.com/image/w%3D2048/sign=5e067f12a918972ba33a07cad2f57b89/b8014a90f603738d27674f24b11bb051f819ec83.jpg&apos;, &apos;http://f.hiphotos.baidu.com/image/w%3D2048/sign=fc9023a7d343ad4ba62e41c0b63a5baf/4bed2e738bd4b31ca2a24ab985d6277f9e2ff812.jpg&apos;, &apos;http://f.hiphotos.baidu.com/image/w%3D2048/sign=99191869cebf6c81f7372be88806b035/9345d688d43f8794a159b42fd01b0ef41bd53a08.jpg&apos;, &apos;http://a.hiphotos.baidu.com/image/w%3D2048/sign=4aaddd39718da9774e2f812b8469f919/8b13632762d0f70391b28bd60afa513d2697c5b3.jpg&apos;, &apos;http://g.hiphotos.baidu.com/image/w%3D2048/sign=50df8b2efffaaf5184e386bfb86c95ee/fc1f4134970a304ebbdb83f2d3c8a786c9175c38.jpg&apos; ]; var iCur = 0; var i = 0; xunlei(); oImg.onclick = function() { i++; if (i &lt; arr.length) { oImg.src = arr[i]; } } function xunlei() { oImage.src = arr[iCur]; oImage.onload = function() { iCur++; if (iCur &lt; arr.length) { xunlei(); //递归 } document.title = iCur + &apos; / &apos; + arr.length; } } } &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;img src=&quot;http://b.hiphotos.baidu.com/image/w%3D2048/sign=526ef7bda41ea8d38a227304a332314e/1ad5ad6eddc451dae05f4cedb4fd5266d016320e.jpg&quot; id=&quot;img1&quot; style=&quot;width: 300px;&quot; /&gt; &lt;/body&gt; &lt;/html&gt; 案例2，图片按需加载 &lt;!DOCTYPE HTML&gt; &lt;html&gt; &lt;head&gt; &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot;&gt; &lt;title&gt;无标题文档&lt;/title&gt; &lt;style&gt; #ul1 {margin: 100px auto 0; padding: 0;} li {float: left; margin:0 0 10px 10px; list-style:none; border: 1px solid black;} img {width: 290px; height: 200px; display: block;} &lt;/style&gt; &lt;script&gt; window.onload = function() { var oUl = document.getElementById(&apos;ul1&apos;); var aImg = oUl.getElementsByTagName(&apos;img&apos;); showImage(); window.onscroll = showImage; function showImage() { var scrollTop = document.documentElement.scrollTop || document.body.scrollTop; for (var i=0; i&lt;aImg.length; i++) { if ( !aImg[i].isLoad &amp;&amp; getTop(aImg[i]) &lt; scrollTop + document.documentElement.clientHeight ) { //alert(i); aImg[i].src = aImg[i].getAttribute(&apos;_src&apos;); aImg[i].isLoad = true; } } } function getTop(obj) { var iTop = 0; while(obj) { iTop += obj.offsetTop; obj = obj.offsetParent; } return iTop; } } &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;ul id=&quot;ul1&quot;&gt; &lt;li&gt;&lt;img _src=&quot;img/1.jpg&quot; src=&quot;img/white.JPG&quot; /&gt;&lt;/li&gt; &lt;li&gt;&lt;img _src=&quot;img/2.jpg&quot; src=&quot;img/white.JPG&quot; /&gt;&lt;/li&gt; &lt;li&gt;&lt;img _src=&quot;img/3.jpg&quot; src=&quot;img/white.JPG&quot; /&gt;&lt;/li&gt; &lt;li&gt;&lt;img _src=&quot;img/4.jpg&quot; src=&quot;img/white.JPG&quot; /&gt;&lt;/li&gt; &lt;li&gt;&lt;img _src=&quot;img/5.jpg&quot; src=&quot;img/white.JPG&quot; /&gt;&lt;/li&gt; &lt;li&gt;&lt;img _src=&quot;img/6.jpg&quot; src=&quot;img/white.JPG&quot; /&gt;&lt;/li&gt; &lt;li&gt;&lt;img _src=&quot;img/7.jpg&quot; src=&quot;img/white.JPG&quot; /&gt;&lt;/li&gt; &lt;li&gt;&lt;img _src=&quot;img/1.jpg&quot; src=&quot;img/white.JPG&quot; /&gt;&lt;/li&gt; &lt;li&gt;&lt;img _src=&quot;img/2.jpg&quot; src=&quot;img/white.JPG&quot; /&gt;&lt;/li&gt; &lt;li&gt;&lt;img _src=&quot;img/3.jpg&quot; src=&quot;img/white.JPG&quot; /&gt;&lt;/li&gt; &lt;li&gt;&lt;img _src=&quot;img/4.jpg&quot; src=&quot;img/white.JPG&quot; /&gt;&lt;/li&gt; &lt;li&gt;&lt;img _src=&quot;img/5.jpg&quot; src=&quot;img/white.JPG&quot; /&gt;&lt;/li&gt; &lt;li&gt;&lt;img _src=&quot;img/6.jpg&quot; src=&quot;img/white.JPG&quot; /&gt;&lt;/li&gt; &lt;li&gt;&lt;img _src=&quot;img/7.jpg&quot; src=&quot;img/white.JPG&quot; /&gt;&lt;/li&gt; &lt;li&gt;&lt;img _src=&quot;img/1.jpg&quot; src=&quot;img/white.JPG&quot; /&gt;&lt;/li&gt; &lt;li&gt;&lt;img _src=&quot;img/2.jpg&quot; src=&quot;img/white.JPG&quot; /&gt;&lt;/li&gt; &lt;li&gt;&lt;img _src=&quot;img/3.jpg&quot; src=&quot;img/white.JPG&quot; /&gt;&lt;/li&gt; &lt;li&gt;&lt;img _src=&quot;img/4.jpg&quot; src=&quot;img/white.JPG&quot; /&gt;&lt;/li&gt; &lt;li&gt;&lt;img _src=&quot;img/5.jpg&quot; src=&quot;img/white.JPG&quot; /&gt;&lt;/li&gt; &lt;li&gt;&lt;img _src=&quot;img/6.jpg&quot; src=&quot;img/white.JPG&quot; /&gt;&lt;/li&gt; &lt;li&gt;&lt;img _src=&quot;img/7.jpg&quot; src=&quot;img/white.JPG&quot; /&gt;&lt;/li&gt; &lt;li&gt;&lt;img _src=&quot;img/1.jpg&quot; src=&quot;img/white.JPG&quot; /&gt;&lt;/li&gt; &lt;li&gt;&lt;img _src=&quot;img/2.jpg&quot; src=&quot;img/white.JPG&quot; /&gt;&lt;/li&gt; &lt;li&gt;&lt;img _src=&quot;img/3.jpg&quot; src=&quot;img/white.JPG&quot; /&gt;&lt;/li&gt; &lt;li&gt;&lt;img _src=&quot;img/4.jpg&quot; src=&quot;img/white.JPG&quot; /&gt;&lt;/li&gt; &lt;li&gt;&lt;img _src=&quot;img/5.jpg&quot; src=&quot;img/white.JPG&quot; /&gt;&lt;/li&gt; &lt;li&gt;&lt;img _src=&quot;img/6.jpg&quot; src=&quot;img/white.JPG&quot; /&gt;&lt;/li&gt; &lt;li&gt;&lt;img _src=&quot;img/7.jpg&quot; src=&quot;img/white.JPG&quot; /&gt;&lt;/li&gt; &lt;li&gt;&lt;img _src=&quot;img/1.jpg&quot; src=&quot;img/white.JPG&quot; /&gt;&lt;/li&gt; &lt;li&gt;&lt;img _src=&quot;img/2.jpg&quot; src=&quot;img/white.JPG&quot; /&gt;&lt;/li&gt; &lt;li&gt;&lt;img _src=&quot;img/3.jpg&quot; src=&quot;img/white.JPG&quot; /&gt;&lt;/li&gt; &lt;li&gt;&lt;img _src=&quot;img/4.jpg&quot; src=&quot;img/white.JPG&quot; /&gt;&lt;/li&gt; &lt;li&gt;&lt;img _src=&quot;img/5.jpg&quot; src=&quot;img/white.JPG&quot; /&gt;&lt;/li&gt; &lt;li&gt;&lt;img _src=&quot;img/6.jpg&quot; src=&quot;img/white.JPG&quot; /&gt;&lt;/li&gt; &lt;li&gt;&lt;img _src=&quot;img/7.jpg&quot; src=&quot;img/white.JPG&quot; /&gt;&lt;/li&gt; &lt;li&gt;&lt;img _src=&quot;img/1.jpg&quot; src=&quot;img/white.JPG&quot; /&gt;&lt;/li&gt; &lt;li&gt;&lt;img _src=&quot;img/2.jpg&quot; src=&quot;img/white.JPG&quot; /&gt;&lt;/li&gt; &lt;li&gt;&lt;img _src=&quot;img/3.jpg&quot; src=&quot;img/white.JPG&quot; /&gt;&lt;/li&gt; &lt;li&gt;&lt;img _src=&quot;img/4.jpg&quot; src=&quot;img/white.JPG&quot; /&gt;&lt;/li&gt; &lt;li&gt;&lt;img _src=&quot;img/5.jpg&quot; src=&quot;img/white.JPG&quot; /&gt;&lt;/li&gt; &lt;li&gt;&lt;img _src=&quot;img/6.jpg&quot; src=&quot;img/white.JPG&quot; /&gt;&lt;/li&gt; &lt;li&gt;&lt;img _src=&quot;img/7.jpg&quot; src=&quot;img/white.JPG&quot; /&gt;&lt;/li&gt; &lt;li&gt;&lt;img _src=&quot;img/1.jpg&quot; src=&quot;img/white.JPG&quot; /&gt;&lt;/li&gt; &lt;li&gt;&lt;img _src=&quot;img/2.jpg&quot; src=&quot;img/white.JPG&quot; /&gt;&lt;/li&gt; &lt;li&gt;&lt;img _src=&quot;img/3.jpg&quot; src=&quot;img/white.JPG&quot; /&gt;&lt;/li&gt; &lt;li&gt;&lt;img _src=&quot;img/4.jpg&quot; src=&quot;img/white.JPG&quot; /&gt;&lt;/li&gt; &lt;li&gt;&lt;img _src=&quot;img/5.jpg&quot; src=&quot;img/white.JPG&quot; /&gt;&lt;/li&gt; &lt;li&gt;&lt;img _src=&quot;img/6.jpg&quot; src=&quot;img/white.JPG&quot; /&gt;&lt;/li&gt; &lt;li&gt;&lt;img _src=&quot;img/7.jpg&quot; src=&quot;img/white.JPG&quot; /&gt;&lt;/li&gt; &lt;li&gt;&lt;img _src=&quot;img/1.jpg&quot; src=&quot;img/white.JPG&quot; /&gt;&lt;/li&gt; &lt;li&gt;&lt;img _src=&quot;img/2.jpg&quot; src=&quot;img/white.JPG&quot; /&gt;&lt;/li&gt; &lt;li&gt;&lt;img _src=&quot;img/3.jpg&quot; src=&quot;img/white.JPG&quot; /&gt;&lt;/li&gt; &lt;li&gt;&lt;img _src=&quot;img/4.jpg&quot; src=&quot;img/white.JPG&quot; /&gt;&lt;/li&gt; &lt;li&gt;&lt;img _src=&quot;img/5.jpg&quot; src=&quot;img/white.JPG&quot; /&gt;&lt;/li&gt; &lt;li&gt;&lt;img _src=&quot;img/6.jpg&quot; src=&quot;img/white.JPG&quot; /&gt;&lt;/li&gt; &lt;li&gt;&lt;img _src=&quot;img/7.jpg&quot; src=&quot;img/white.JPG&quot; /&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/body&gt; &lt;/html&gt;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[HTML5之canvas基础]]></title>
      <url>%2F2017%2F04%2F07%2FHTML5%E4%B9%8Bcanvas%E5%9F%BA%E7%A1%80%2F</url>
      <content type="text"><![CDATA[]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[HTML5详解之拖放操作事件]]></title>
      <url>%2F2017%2F04%2F06%2FHTML5%E6%8B%96%E6%94%BE%E4%BA%8B%E4%BB%B6%2F</url>
      <content type="text"><![CDATA[初步了解HTML5的拖放事件，实现页内元素或外部元素与目标元素的交互。 draggable 给元素添加这个属性，设置为true，元素就可以拖拽了 拖拽元素事件 事件对象为被拖拽元素 dragstart 拖拽前触发 drag 拖拽前、拖拽结束之间，连续触发。跟mousemove一样，但是它停止移动的时候也会连续触发 dragend 拖拽结束触发 目标元素事件 事件对象为目标元素 dragenter 进入目标元素触发，相当于mouseover dragover 进入目标、离开目标之间，连续触发 如果要想触发drop，就必须在dragover当中阻止默认事件。 ev.preventDefault() / return false; dragleave 离开目标元素触发，相当于mouseout drop 在目标元素上释放鼠标触发,前提是必须在ondragover事件中阻止掉默认事件才能触发 拖放事件的执行顺序 drop不触发的时候 dragstart &gt; drag &gt; dragenter &gt; dragover &gt; dragleave &gt; dragend drop触发的时候(dragover的时候阻止默认事件) dragstart &gt; drag &gt; dragenter &gt; dragover &gt; drop &gt; dragend 不能释放的光标和能释放的光标不一样 dataTransfer对象 要解决火狐下不能拖拽的问题，必须设置ev.dataTransfer对象的setData方法才可以拖拽除图片以外的其他标签 setData() 设置数据 key和value(必须是字符串) ev.dataTransfer.setData(‘name’,’hello’); getData() : 获取数据，根据key值，获取对应的value ev.dataTransfer.getData(‘name’); effectAllowed effectAllowed : 设置光标样式(none, copy, copyLink, copyMove, link, linkMove, move, all 和 uninitialized) 例：ev.dataTransfer.effectAllowed = ‘光标样式’; setDragImage ev.dataTransfer.setDragImage(oDiv,0,0); 三个参数：指定的元素，坐标X，坐标Y 可以让拖拽过程中的元素的形状变成指定的元素样子，比如说图片 拖放事件案例1 &lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD XHTML 1.0 Transitional//EN&quot; &quot;http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd&quot;&gt; &lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot;&gt; &lt;head&gt; &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot; /&gt; &lt;title&gt;无标题文档&lt;/title&gt; &lt;style&gt; li{ list-style:none; width:100px; height:30px; background:yellow; margin:10px;} #div1{ width:100px; height:100px; background:red; margin:200px;} &lt;/style&gt; &lt;script&gt; window.onload = function(){ var oUl = document.getElementsByTagName(&apos;ul&apos;)[0]; var aLi = oUl.getElementsByTagName(&apos;li&apos;); var oDiv = document.getElementById(&apos;div1&apos;); var i = 0; for(var i=0;i&lt;aLi.length;i++){ aLi[i].index = i; aLi[i].ondragstart = function(ev){ //开始拖拽触发事件 var ev = ev || window.event; ev.dataTransfer.setData(&apos;name&apos;,this.index); //拖拽的时候获取li的索引值 ev.dataTransfer.effectAllowed = &apos;copy&apos;; //设置拖拽时候的光标样式 ev.dataTransfer.setDragImage(oDiv,0,0); //指定拖放时候的元素样式 this.style.background = &apos;green&apos;; }; /*aLi[i].ondrag = function(){ //开始与结束连续触发 document.title = i++; };*/ aLi[i].ondragend = function(){ //结束拖放时的时间 this.style.background = &apos;yellow&apos;; }; } oDiv.ondragenter = function(){ //移入目标元素时触发的事件 this.style.background = &apos;blue&apos;; }; oDiv.ondragover = function(ev){ //悬停在目标元素的时候触发 //enter和leave之间连续触发 //document.title = i++; ev.preventDefault(); //要想触发drop事件，就必须在dragover当中阻止默认事件 }; oDiv.ondragleave = function(){ //离开目标元素的时候触发 this.style.background = &apos;red&apos;; }; oDiv.ondrop = function(ev){ //在目标元素上释放鼠标之后触发，必须先在dragover时间中阻止掉默认事件 oUl.removeChild( aLi[ev.dataTransfer.getData(&apos;name&apos;)] ); //删除拖动的li元素 for(var i=0;i&lt;aLi.length;i++){ aLi[i].index = i; //删除元素之后索引值会发生变化，所以需要在这里重新生成一下索引值 } }; }; &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;ul&gt; &lt;li draggable=&quot;true&quot;&gt;a&lt;/li&gt; &lt;li draggable=&quot;true&quot;&gt;b&lt;/li&gt; &lt;li draggable=&quot;true&quot;&gt;c&lt;/li&gt; &lt;/ul&gt; &lt;div id=&quot;div1&quot;&gt;&lt;/div&gt; &lt;/body&gt; &lt;/html&gt; files ev.dataTransfer.files; 获取外部拖拽的文件，返回一个filesList列表 filesList下有个type属性，返回文件的类型 var fs = ev.dataTransfer.files; //获取外部拖拽的文件 //alert(fs.length); //获取外部拖拽的文件的长度 //alert( fs[0].type ); //获取外部拖拽的文件的类型和格式 FileReader(读取文件信息) 对象，new FileReader();,下面有两个方法 readAsDataURL new FileReader().readAsDataURL() 参数为要读取的文件对象，将文件读取为DataUrl onload new FileReader().onload = function(){} 当读取文件成功完成的时候触发此事件 this.result , 来获取读取的文件数据，如果是图片，将返回base64格式的图片数据 拖放事件案例2-上传图片预览 &lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD XHTML 1.0 Transitional//EN&quot; &quot;http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd&quot;&gt; &lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot;&gt; &lt;head&gt; &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot; /&gt; &lt;title&gt;无标题文档&lt;/title&gt; &lt;style&gt; #div1{ width:200px; height:200px; background:red; margin:100px;} &lt;/style&gt; &lt;script&gt; window.onload = function(){ var oDiv = document.getElementById(&apos;div1&apos;); var oUl = document.getElementById(&apos;ul1&apos;); oDiv.ondragenter = function(){ this.innerHTML = &apos;可以释放啦&apos;; }; oDiv.ondragover = function(ev){ ev.preventDefault(); }; oDiv.ondragleave = function(){ this.innerHTML = &apos;将文件拖拽到此区域&apos;; }; oDiv.ondrop = function(ev){ ev.preventDefault(); //为了防止浏览器打开外部文件，所以需要阻止掉浏览器的默认操作事件 var fs = ev.dataTransfer.files; //获取外部拖拽的文件 //alert(fs.length); //获取外部拖拽的文件的长度 //alert( fs[0].type ); //获取外部拖拽的文件的类型和格式 for(var i=0;i&lt;fs.length;i++){ if(fs[i].type.indexOf(&apos;image&apos;)!=-1){ var fd = new FileReader(); //创建一个FileReader对象 fd.readAsDataURL( fs[i] ); //将拖放进来的文件读取为DataUrl fd.onload = function(){ //读取完成之后执行onload事件 var oLi = document.createElement(&apos;li&apos;); var oImg = document.createElement(&apos;img&apos;); oImg.src = this.result; //this.result 获取读取的文件的数据 oLi.appendChild(oImg); oUl.appendChild(oLi); }; } else{ alert(&apos;亲，请上传图片类型&apos;); } } }; }; &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;div1&quot;&gt;将文件拖拽到此区域&lt;/div&gt; &lt;ul id=&quot;ul1&quot;&gt;&lt;/ul&gt; &lt;/body&gt; &lt;/html&gt;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[HTML5详解之HTML5的新特性]]></title>
      <url>%2F2017%2F04%2F06%2FHTML5%E8%AF%A6%E8%A7%A3%2F</url>
      <content type="text"><![CDATA[HTML5 最新API兼容查询 http://caniuse.com/#index 新的选择器、JSON新方法、自定义数据和JS延迟加载、历史管理 新的选择器 新的HTML5对于提供了类似于JQ一样的获取元素方法 querySelector 类似于JQ的$()，不同的地方是它只能获取一组元素的第一个 / 如果一个元素就获取它自身 document.querySelector(&apos;#div1&apos;); //通过ID 获取元素 document.querySelector(&apos;.box&apos;); //通过class 获取元素 document.querySelector(&apos;div&apos;); //通过元素标签 获取元素 document.querySelector(&apos;[title=hello]&apos;); //通过自定义属性 获取元素 兼容： 能兼容到IE8含以上 querySelectorAll 这个方法同querySelector一样，区别在于它能获取一组元素 document.querySelector(‘.box’); //获取一组元素 getElementByClassName 这个方法只能针对className document.getElementByClassName(‘box’); // 同getElementById一样，不需要加前缀 兼容： 能兼容到IE9含以上 获取class列表属性 classList alert(oDiv.classList); 返回类似一个数组的集合 alert(oDiv.classList.length); : class的长度 //同JQ的addClass(),removeClass(),toggleClass()类似 alert(oDiv.classList.add(&apos;box1&apos;)); : 添加class方法 alert(oDiv.classList.oremove(&apos;box1&apos;) : 删除class方法 oDiv.classList.toggle(&apos;box2&apos;) : 切换class方法 JSON新方法 以前在ajax下有一个能将JSON转成字符串的方法-eval。 HTML5又新出了两个方法 parse() : 把字符串转成json，字符串中的属性要严格的加上引号，一定要是严格的JSON形式。 var str = &apos;{&quot;name&quot;:&quot;hello&quot;}&apos;; //一定是严格的JSON形式 var json = JSON.parse(str); alert( json.name ); stringify() : 把json转化成字符串，会自动的把双引号加上 var json = {name : &quot;hello&quot;}; var str = JSON.stringify(json); alert( str ); //“{“name” : &quot;hello&quot;}” 我们还可以用来深度克隆新对象 这种直接赋值的方法，b和a会存在引用关系，b修改之后会影响到a var a = { name : &apos;hello&apos; }; var b = a; b.name = &apos;hi&apos;; alert( a.name ); // hi 通过for in方法可以实现拷贝，但也只是浅拷贝，如果name也是一个json还是会存在引用关系 var a = { name : &apos;hello&apos; }; var b = {}; for(var attr in a){ b[attr] = a[attr]; } b.name = &apos;hi&apos;; alert( a.name ); 通过stringify转成字符串，然后通过parse解析再赋给b。这种方法就不会存在引用关系，而且不管里面有多少个json都不会受影响 var a = { name : { age : 100 } }; var str = JSON.stringify(a); var b = JSON.parse(str); b.name.age = 200; alert( a.name.age ); 关于兼容 JSON的新方法会存在一些兼容问题，如果不想用eval代替，可以去 JSON的官网Javasceript项目下载一个JSON2.JS文件做兼容。 eval()与JSON.parse()的区别 eval: 可以解析任何字符串转化成JS JSON.parse: 只能解析JSON形式的字符串变成JS var str = &apos;function show(){alert(123)}&apos;; eval(str); show(); //能执行 var str = &apos;function show(){alert(123)}&apos;; JSON.parse(str); show(); //不能执行 相对来说parse这种解析方式会更好些，因为eval会解析一写不安全的字符串，比如说病毒，而parse只能解析JSON形式的字符串，会更严谨安全性更高一些。 自定义数据dataset 在以前的版本里，如果我们要获取数据只能通过getAttribute来获取，但是它存在的很多兼容性问题 HTML5出了一个新的方法，dataset方法，可以用来获取自定义属性。 1. 在书写自定义属性是，需要在属性名前面加上data，比如data-属性名 2. 获取属性的时候，通过它的专用方法获取，元素.dataset.属性名 data-name : dataset.name data-name-first : dataset.nameFirst &lt;script&gt; window.onload = function(){ var oDiv = document.getElementById(&apos;div1&apos;); //alert( oDiv.dataset.miaov ); alert( oDiv.dataset.miaovAll ); }; &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;div1&quot; data-miaov=&quot;妙味&quot; data-miaov-all=&quot;妙味课堂&quot;&gt;div&lt;/div&gt; &lt;/body&gt; JS延迟加载 JS的加载会影响后面的内容加载，很多浏览器都采用了并行加载JS，但还是会影响其他内容 所以HTML5出了两个新方法 defer 给谁加上defer=”defer”属性之后，它就会被延迟到onload之前执行 如果有几个js文件都被加上defer属性，延迟之后，它的执行顺序还是不变，从上往下执行 &lt;script src=&quot;a.js&quot; defer=&quot;defer&quot;&gt;&lt;/script&gt; &lt;script src=&quot;b.js&quot; defer=&quot;defer&quot;&gt;&lt;/script&gt; &lt;script src=&quot;c.js&quot; defer=&quot;defer&quot;&gt;&lt;/script&gt; async 异步加载，加载完就触发，有顺序问题 可以几个JS文件和body一起同时加载执行 &lt;script src=&quot;a.js&quot; async =&quot;async&quot;&gt;&lt;/script&gt; &lt;script src=&quot;b.js&quot; async =&quot;async&quot;&gt;&lt;/script&gt; &lt;script src=&quot;c.js&quot; async =&quot;async&quot;&gt;&lt;/script&gt; 要注意的问题 如果JS文件里有DOM操作的话，会影响整个页面的布局。它的特性是谁先加载完，就先执行谁。 如果b.js先加载完，就会先执行b.js，但是如果b.js需要依赖a.js的话就会出现问题。 所以推荐不相互依赖的js文件使用此方法 Labjs库 因为defer和async都有兼容性问题，所以这里推荐一个异步加载库 Labjs官网 http://www.labjs.com/ 一个解析Labjs的博客 http://www.cnblogs.com/yuzhongwusan/archive/2013/04/14/3020559.html 历史管理 window.location.hash ，通过这个方法来获取和设置hash值 onhashchange 当hash值改变的时候触发 案例： 随机获取7个数字，并且通过历史管理来记录它 &lt;script&gt; window.onload = function(){ var oInput = document.getElementById(&apos;input1&apos;); var oDiv = document.getElementById(&apos;div1&apos;); var json = {}; oInput.onclick = function(){ var num = Math.random(); //随机获取一个0-1之间的值 var arr = randomNum(35,7); json[num] = arr; //在JSON里存入每个hash值对应的数组 oDiv.innerHTML = arr; window.location.hash = num; //hash值等于这个值 }; window.onhashchange = function(){ //当浏览器的hash值改变的时候触发事件 oDiv.innerHTML = json[window.location.hash.substring(1)]; //通过获取浏览器的hash值，来找到json中对应hash的数据 }; function randomNum(iAll,iNow){ //封装一个随机获取某几个数字的方法 var arr = []; var newArr = []; for(var i=1;i&lt;=iAll;i++){ arr.push(i); } for(var i=0;i&lt;iNow;i++){ newArr.push( arr.splice( Math.floor(Math.random()*arr.length) ,1) ); } return newArr; } }; &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;input type=&quot;button&quot; value=&quot;随机选择&quot; id=&quot;input1&quot;&gt; &lt;div id=&quot;div1&quot;&gt;&lt;/div&gt; &lt;/body&gt; history 通过history来创建历史管理，history需要在服务器下运行 pushState history.pushState(): 有3个参数 第一个参数是用来存放，需要存进历史管理的数据 第二个参数用来存放历史管理的标题（每次改变历史管理，都会让title发生变化，但现在还未实现） 第三个参数是地址 popstate window.onpopstate = function(ev){}; 通过它来获取存入历史管理的数据 event下有个一个state属性，它就等于上面历史管理存入的数据。 history案例：需要放在服务器下才能测试 &lt;script&gt; window.onload = function(){ var oInput = document.getElementById(&apos;input1&apos;); var oDiv = document.getElementById(&apos;div1&apos;); oInput.onclick = function(){ var arr = randomNum(35,7); history.pushState(arr,&apos;&apos;,arr); //存入历史管理的数据，第一个参数 数据，第二个参数 标题，第三个参数 网址（可选） oDiv.innerHTML = arr; //网址是虚假的，需在服务器指定对应页面，不然刷新找不到页面 }; window.onpopstate = function(ev){ oDiv.innerHTML = ev.state; //获取刚才存入历史管理的数据，ev.state就是刚才的数据 }; function randomNum(iAll,iNow){ var arr = []; var newArr = []; for(var i=1;i&lt;=iAll;i++){ arr.push(i); } for(var i=0;i&lt;iNow;i++){ newArr.push( arr.splice( Math.floor(Math.random()*arr.length) ,1) ); } return newArr; } }; &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;input type=&quot;button&quot; value=&quot;随机选择&quot; id=&quot;input1&quot;&gt; &lt;div id=&quot;div1&quot;&gt;&lt;/div&gt; &lt;/body&gt; 注意：网址是虚假的，需在服务器指定对应页面，不然刷新找不到页面]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[HTML5详解之自定义播放器]]></title>
      <url>%2F2017%2F03%2F31%2FH5%E8%87%AA%E5%AE%9A%E4%B9%89%E6%92%AD%E6%94%BE%E5%99%A8%2F</url>
      <content type="text"><![CDATA[关于自定义播放器的笔记，写给自己看的，仅供参考 音频和视频 audio 音频播放标签 video 视频播放标签 soure 兼容视频或音频不同格式的标签 &lt;video controls&gt; &lt;source src=&quot;Intermission-Walk-in.ogv&quot;&gt;&lt;/source&gt; &lt;source src=&quot;Intermission-Walk-in_512kb.mp4&quot;&gt;&lt;/source&gt; &lt;/video&gt; 视频容器 容器文件：类似于压缩了一组文件，包括音频轨道，视频轨道，封面，标题，字幕等。 格式：.avi, .flv, .mp4, .mkv, .ogv等。 编解码器 由于原始的视频容器非常大，网页加载速度过慢，所以浏览器自带了一个解码器，叫做编解码器。 编解码器先将视频重新编码，然后在播放的时候再解码。编码之后会压缩文件，将其质量变得很小，方便页面快速加载。 音频编解码器： AAC、MPEG-3、Ogg Vorbis 视频编解码器： H.264、VP8、Ogg Theora 媒体元素 controls 系统自带的播放控件 添加显示/不添加隐藏用户控制界面 autoplay 媒体是否自动播放 loop 媒体是否循环播放 currentTime 获取开始到播放现在所用的时间，可设置 duration 媒体总时间(只读) volume 0.0-1.0的音量相对值，可设置 muted 是否静音 ，返回布尔值，静音返回true，非静音返回false autobuffer 开始的时候是否缓冲加载，autoplay自动播放的时候，忽略此属性 paused 媒体是否暂停(只读)。返回布尔值，暂停状态返回true，播放状态返回false ended 媒体是否播放完毕(只读)。返回布尔值，结束返回true，未结束返回false error 媒体发生错误的时候，返回错误代码 (只读)，无错返回null error.code 1.用户终止 2.网络错误 3.解码错误 4.URL无效 buffered; 返回已缓冲区域，TimeRanges currentSrc 以字符串的形式返回当前媒体的URL地址(只读) 示例 &lt;script&gt; window.onload = function(){ var oA = document.getElementById(&apos;a1&apos;); setInterval(function(){ console.log(oA.currentTime); },1000); //每1秒获取一次播放的时间 oA.currentTime = 60; //获取现在播放的时间，可设置播放的时间 console.log( oA.duration ); //获取媒体的总时间 console.log( oA.volume ); //获取音量值， console.log( oA.muted ); console.log( oA.paused ); console.log( oA.ended ); console.log( oA.error ); console.log( oA.currentSrc ); }; &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;audio id=&quot;a1&quot; controls src=&quot;johann_sebastian_bach_air.mp3&quot;&gt;&lt;/audio&gt; &lt;/body&gt; play() : 媒体播放 pause() : 媒体暂停 load() : 重新加载媒体，当修改了媒体链接的时候，需要调用此方法进行重新加载媒体资源。 示例 &lt;script&gt; window.onload = function(){ var oV = document.getElementById(&apos;v1&apos;); var oInput = document.getElementById(&apos;input1&apos;); var aS = document.getElementsByTagName(&apos;source&apos;); oV.onmouseover = function(){ this.play(); //鼠标移入播放 }; oV.onmouseout = function(){ this.pause(); //鼠标移出暂停 }; oInput.onclick = function(){ aS[0].src = &apos;xxxx.mp4&apos;; aS[1].src = &apos;yyyy.mp4&apos;; oV.load(); //点击按钮修改链接之后需要调用此方法，重新加载 }; }; &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;input type=&quot;button&quot; value=&quot;重新加载&quot; id=&quot;input1&quot; /&gt; &lt;video id=&quot;v1&quot;&gt; &lt;source src=&quot;Intermission-Walk-in.ogv&quot;&gt;&lt;/source&gt; &lt;source src=&quot;Intermission-Walk-in_512kb.mp4&quot;&gt;&lt;/source&gt; &lt;/video&gt; &lt;/body&gt; Video额外特性 poster 视频播放前的预览图片 video.poster = ‘图片地址’ width、height 设置视频的尺寸 videoWidth、 videoHeight 视频的实际尺寸(只读) 媒体事件 onloadstart 在 Internet Explorer 开始查找媒体数据时引发。在从站点请求视频（或音频）资源时发生此事件，并且每个请求只发生一次。 onprogress 引发此事件以指示正在下载媒体内容。下载完成后停止引发。 onsuspend 媒体暂停的时候触发的事件 onemptied 当发生故障并且文件突然不可用时运行的事件（比如连接意外断开时）。 onstalled 在下载被中断三秒以上时引发。这可以指示网络问题。 onplay： 媒体开始播放时触发的事件 onpause onloadedmetadata onloadeddata onwaiting 在播放由于视频的下一帧不可用（可能需要缓冲）而停止时引发。 onplaying 回放 oncanplay oncanplaythrough onseeking onseeked ontimeupdate 播放时间改变时触发 onended: 当媒体结束时触发的事件（可发送类似“感谢观看”之类的消息） onratechange ondurationchange 资源长度改变时触发 onvolumechange 音量改变时触发 参考链接 全屏 启动全屏模式 全屏API requestFullscreen方法在一些老的浏览器里面依然使用带前缀形式的方法名,因此可能需要进行检测判断: 兼容个版本浏览器,需要带上内核前缀，未来应该都不需要了。 function launchFullScreen(element) { if(element.requestFullscreen) { element.requestFullscreen(); } else if(element.mozRequestFullScreen) { element.mozRequestFullScreen(); } else if(element.webkitRequestFullscreen) { element.webkitRequestFullscreen(); } else if(element.msRequestFullscreen) { element.msRequestFullscreen(); } } // 在支持全屏的浏览器中启动全屏 // 整个页面 launchFullScreen(document.documentElement); // 某个元素 launchFullScreen(document.getElementById(&quot;videoElement&quot;)); 将需要全屏显示的DOM元素作为参数,调用此方法即可让window进入全屏状态,有时候可能需要用户同意(浏览器自己和用户交互),假若用户拒绝,则可能出现各种不完全的全屏. 如果用户同意进入全屏,那么工具栏以及其他浏览器组件会隐藏起来,使document框架的宽度和高度横跨整个屏幕. 退出全屏模式 使用 exitFullscreen 方法可以使浏览器退出全屏,返回原先的布局. 该方法在一些老的浏览器上也是支持前缀方法. 请注意: exitFullscreen 只能通过 document 对象调用 —— 而不是使用普通的 DOM element. // 退出 fullscreen function exitFullscreen() { if(document.exitFullscreen) { document.exitFullscreen(); } else if(document.mozExitFullScreen) { document.mozExitFullScreen(); } else if(document.webkitExitFullscreen) { document.webkitExitFullscreen(); } } Fullscreen 属性与事件 document.fullscreenElement: 当前处于全屏状态的元素 element. document.fullscreenEnabled: 标记 fullscreen 当前是否可用. 当进入/退出 全屏模式时,会触发 fullscreenchange 事件: var fullscreenElement = document.fullscreenEnabled || document.mozFullscreenElement || document.webkitFullscreenElement; var fullscreenEnabled = document.fullscreenEnabled || document.mozFullscreenEnabled || document.webkitFullscreenEnabled; Fullscreen CSS 浏览器提供了一些有用的 fullscreen CSS 控制规则: /* html */ :-webkit-full-screen { /* properties */ } :-moz-fullscreen { /* properties */ } :fullscreen { /* properties */ } /* deeper elements */ :-webkit-full-screen video { width: 100%; height: 100%; } /* styling the backdrop */ ::backdrop { /* properties */ } 在某些情况下,WebKit需要一些特殊处理,所以在处理多媒体时,你可能需要上面的代码。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[ajax初探]]></title>
      <url>%2F2017%2F03%2F31%2F%E5%85%B3%E4%BA%8Eajax%2F</url>
      <content type="text"><![CDATA[个人学习笔记，仅供参考 什么是Ajax? Asynchronous JavaScript and XML（异步JavaScript和XML) 节省用户操作，时间，提高用户体验，减少数据请求 传输获取数据 创建Ajax对象 标准下： new XMLHttpRequest(); 获取服务器地址，创建一个ajax对象 var xhr = new XMLHttpRequest(); IE6下： new ActiveXObject(&apos;Microsoft.XMLHttp&apos;); //IE6下d插件，括号内是获取插件的名称 var xhr = new ActiveXObject(&apos;Microsoft.XMLHttp&apos;); 兼容标准与IE6： if (window.XMLHttpRequest) { xhr = new XMLHttpRequest(); } else { xhr = new ActiveXObject(&apos;Microsoft.XMLHTTP&apos;); } 异常处理机制： 代码尝试执行try这个块中的内容,如果有错误，则会执行catch{},并且传入错误信息参数 try { //alert(a); //a不存在，错误 //throw new Error(&apos;错了错了&apos;); //手动报错，写入这段代码，即使没错，系统也会认为错误 } catch (e) { //括号里传入的参数，就是为什么错误的提示 alert(e); //弹出错误的原因的提示 } 示例：try { xhr = new XMLHttpRequest(); } catch (e) { xhr = new ActiveXObject(&apos;Microsoft.XMLHTTP&apos;); } open方法： 设置参数信息 1. 打开方式; 2. 地址; 3. 是否异步; 示例：xhr.open(&apos;get&apos;,&apos;1.txt&apos;,true); 1. 异步：-&gt;非阻塞模式-&gt;前面代码不会影响后面代码的执行 2. 同步：-&gt;阻塞模式-&gt;前面代码会影响后面代码的执行 2. PS：大量情况下采用异步，当后续代码需要前面的代码的时候可以通过回调函数来解决。 send方法： 发送请求： 通过它才能把你的数据请求发送给后端。 示例：xhr.send(); responseText： ajax请求返回的内容就被存放到这个属性下面。 返回以文本字符串形式存放的内容 示例: xhr.responseText responseXML： 返回XML形式的内容 请求状态监控 onreadystatechange事件 当readyState状态值发生改变的时候触发 readyState属性：请求状态 调用这个方法之后会返回5个数字类型的状态值，不同数字代表不同的意思 0 （初始化）还没有调用open()方法 1 （载入）已调用send()方法，正在发送请求 2 （载入完成）send()方法完成，已收到全部响应内容 3 （解析）正在解析响应内容 4 （完成）响应内容解析完成，可以在客户端调用了 status属性：服务器状态码 服务器(请求资源)的状态 返回Http状态码 返回的内容可以做容错处理，返回200表示成功 404表示错误 以上内容综合示例： oBtn.onclick=function(){ var xhr = null; if (window.XMLHttpRequest) { xhr = new XMLHttpRequest(); } else { xhr = new ActiveXObject(&apos;Microsoft.XMLHTTP&apos;); } //这一步是兼容标准和IE6的对象创建 xhr.open(&apos;get&apos;,&apos;1.txt&apos;,true); //确定发送的方式，地址，是否异步 xhr.send(); //发送请求 xhr.onreadystatechange = function(){ //当状态值改变的时候触发事件 if(xhr.readyState == 4){ //状态到第4步的时候执行里面的文本 if(xhr.status == 200){ //容错处理，200弹出内容， alert(xhr.responseText); //否则弹出错误信息 } else{ alert(&apos;出错了，Err:&apos; + xhr.status) } } } } 应用中get和post的区别处理： get方式，用于获取数据。 1. 优点：便于分享 2. 缺点：有缓存问题，每次请求的地址如果不改变就会始终读取浏览器缓存的数据 1. 需要在’url？’后面连接一个随机数 2. 解决方案：加时间戳new Date().getTime() 3. 传输中文的时候，会出现乱码，需要用encodeURI编码后传输 4. 安全系数低，容量有限，几K左右 示例： xhr.open(&apos;get&apos;,&apos;2.get.php?username=&apos;+encodeURI(&apos;刘伟&apos;)+&apos;&amp;age=30&amp;&apos; + new Date().getTime(),true); Post: 1. post方式，用于上传数据。 缺点：不便于分享 2. post方式，数据放在send()里面作为参数传递,需做数据类型声明。 3. 在web的机制下，post是没有缓存问题的。 4. 在做数据声明的时候，已经做了encodeURI编码，所以传输数据的时候无需再做编码 安全系数一般，容量几乎无限。 示例： xhr.open(&apos;post&apos;,&apos;2.post.php&apos;,true); xhr.setRequestHeader(&apos;content-type&apos;, &apos;application/x-www-form-urlencoded&apos;); //申明发送的数据类型 xhr.send(&apos;username=刘伟&amp;age=30&apos;); PS：post方法是用来提交数据的，所以不会产生缓存。 表单数据提交方式： 表单： 数据的提交 action : 数据提交的地址，默认是当前页面 method : 数据提交的方式，默认是get方式 get方式和post方式发送数据的形式都是一样的，只是发送的位置不同，都是采取username=tom&amp;age=30这种形式发送 后端用什么方式接受，前端就应该用什么方式传输，如果后端用REQUEST方式获取数据的话，那么前端不管用get还是post都无所谓。 get 1. get通过url地址传输，可能会被浏览器历史纪录记录下来，泄露用户隐私。 2. get方式只能传送字符串类型的数据，不能传输其他类型。 2. 把数据名称和数据值用 “=” 连接，如果有多个的话，那么他会把多个数据组合用&amp;进行连接，然后把数据放到url?后面传到指定页面 3. url长度限制的原因（每个浏览器都不同），我们不要通过get方式传递过多的数据 post 1. post通过浏览器内部REQUEST HEADERS(请求头)传输，不会被缓存，所以理论上不会泄露用户隐私。 2. post可以传更多的数据类型 2. 理论上传送内容的长度和容量是无限的 enctype : 提交的数据格式，默认application/x-www-form-urlencoded &lt;form action=&quot;1.post.php&quot; method=&quot;post&quot;&gt; &lt;input type=&quot;text&quot; name=&quot;username&quot; /&gt; &lt;input type=&quot;text&quot; name=&quot;age&quot; /&gt; &lt;input type=&quot;submit&quot; value=&quot;提交&quot; /&gt; &lt;/form&gt; JSON转换 stringify : 可以把一个对象转成对应字符串 JSON.stringify()； var arr = [1,2,3]; var j = {left:100}; /*alert( JSON.stringify(arr) );*/ /*alert( JSON.stringify(j) );*/ parse : 可以把字符串转成对应对象 JSON.parse() var s1 = &apos;[100,200,300]&apos;; var a1 = JSON.parse(s1); //alert(a1[0]) var s2 = &apos;{&quot;left&quot;:100}&apos;; //严格模式，key值必须加双引号。 var a2 = JSON.parse(s2); alert(a2.left) eval: 就是计算机字符串里面的值。Var str = ‘1*3+5’ alert(eval(str)); //弹出8 Ajax函数封装 function ajax(method, url, data, success) { var xhr = null; try { xhr = new XMLHttpRequest(); } catch (e) { xhr = new ActiveXObject(‘Microsoft.XMLHTTP’); } if (method == &apos;get&apos; &amp;&amp; data) { url += &apos;?&apos; + data; } xhr.open(method,url,true); if (method == &apos;get&apos;) { xhr.send(); } else { xhr.setRequestHeader(&apos;content-type&apos;, &apos;application/x-www-form-urlencoded&apos;); xhr.send(data); } xhr.onreadystatechange = function() { if ( xhr.readyState == 4 ) { if ( xhr.status == 200 ) { success &amp;&amp; success(xhr.responseText); } else { alert(&apos;出错了,Err：&apos; + xhr.status); } } } } Ajax跨域 跨域: 跨域名。 一个域名下的文件去请求了和他不一样的域名下的资源文件，那么就产生跨域请求。但是在有些方式里面是会被禁止的。 跨域的解决: Jsonp : json with padding ， Jsonp主要是通过script标签去加载外部资源 script标签： src的作用 ： 加载（包含指定的外部文件） 可以跨域包含，并且没有跨域问题。 被包含的资源可以是任何类型的文件(可以是txt,php等) 它只关注被包含的文件的内容是否是合法的JS。 过程： 在资源加载进来之前定义好一个函数，这个函数接收一个参数（数据），函数里面利用这个参数做一些事情。然后在需要的时候通过script标签加载对应远程文件资源，当远程的文件资源被加载进来的时候， 就会去执行我们前面定义好的函数，并且把数据当作这个函数的参数传入进去。 PS：需要做到按需加载，可以使用createElement的方式去动态创建一个script标签元素。 示例： &lt;script&gt; function fn(data) { alert(data); } &lt;/script&gt; &lt;script&gt; window.onload = function() { var oBtn = document.getElementById(&apos;btn&apos;); oBtn.onclick = function() { //当按钮点击的时候再去加载远程资源，让他执行 var oScript = document.createElement(&apos;script&apos;); oScript.src = &apos;2.txt&apos;; document.body.appendChild(oScript); } } &lt;/script&gt; 百度搜索示例： &lt;script&gt; function show(data){ var oUl = document.getElementById(&apos;ul&apos;); var html = &apos;&apos;; if( data.s.length){ oUl.style.display = &apos;block&apos;; for( var i=0; i&lt;data.s.length; i++){ html += &apos;&lt;li&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://www.baidu.com/s?wd=&apos;+data.s[i]+&apos;&quot;&gt;&apos; + data.s[i] + &apos;&lt;/a&gt;&lt;/li&gt;&apos;; } oUl.innerHTML = html; } else{ oUl.style.display = &apos;none&apos;; } } window.onload = function(){ var oQ = document.getElementById(&apos;q&apos;); var oUl = document.getElementById(&apos;ul&apos;); oQ.onkeyup = function(){ if( this.value != &apos;&apos;){ var oScript = document.createElement(&apos;script&apos;); oScript.src = &apos;http://suggestion.baidu.com/su?wd=&apos;+this.value+&apos;&amp;cb=show&apos;; document.body.appendChild(oScript); } else{ oUl.style.display = &apos;none&apos;; } } } &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;input type=&quot;text&quot; id=&quot;q&quot;&gt; &lt;ul id=&quot;ul&quot;&gt;&lt;/ul&gt; &lt;/body&gt;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[时间版运动]]></title>
      <url>%2F2017%2F03%2F29%2F%E6%97%B6%E9%97%B4%E7%89%88%E8%BF%90%E5%8A%A8%2F</url>
      <content type="text"><![CDATA[模仿jQuery的animate时间运动，了解Tween算法。个人笔记，仅供参考。 Tween算法 4个参数 t : current time (当前时间) (当前运动到的位置 可变) b : beginning value (初始值) (元素初始的位置) c : change in value (变化量) (终点值-初始值 = 变化值) d : duration (持续时间) return (目标点) Tween公式代码： var Tween = { linear: function (t, b, c, d){ //匀速 return c*t/d + b; }, easeIn: function(t, b, c, d){ //加速曲线 return c*(t/=d)*t + b; }, easeOut: function(t, b, c, d){ //减速曲线 return -c *(t/=d)*(t-2) + b; }, easeBoth: function(t, b, c, d){ //加速减速曲线 if ((t/=d/2) &lt; 1) { return c/2*t*t + b; } return -c/2 * ((--t)*(t-2) - 1) + b; }, easeInStrong: function(t, b, c, d){ //加加速曲线 return c*(t/=d)*t*t*t + b; }, easeOutStrong: function(t, b, c, d){ //减减速曲线 return -c * ((t=t/d-1)*t*t*t - 1) + b; }, easeBothStrong: function(t, b, c, d){ //加加速减减速曲线 if ((t/=d/2) &lt; 1) { return c/2*t*t*t*t + b; } return -c/2 * ((t-=2)*t*t*t - 2) + b; }, elasticIn: function(t, b, c, d, a, p){ //正弦衰减曲线（弹动渐入） if (t === 0) { return b; } if ( (t /= d) == 1 ) { return b+c; } if (!p) { p=d*0.3; } if (!a || a &lt; Math.abs(c)) { a = c; var s = p/4; } else { var s = p/(2*Math.PI) * Math.asin (c/a); } return -(a*Math.pow(2,10*(t-=1)) * Math.sin( (t*d-s)*(2*Math.PI)/p )) + b; }, elasticOut: function(t, b, c, d, a, p){ //正弦增强曲线（弹动渐出） if (t === 0) { return b; } if ( (t /= d) == 1 ) { return b+c; } if (!p) { p=d*0.3; } if (!a || a &lt; Math.abs(c)) { a = c; var s = p / 4; } else { var s = p/(2*Math.PI) * Math.asin (c/a); } return a*Math.pow(2,-10*t) * Math.sin( (t*d-s)*(2*Math.PI)/p ) + c + b; }, elasticBoth: function(t, b, c, d, a, p){ if (t === 0) { return b; } if ( (t /= d/2) == 2 ) { return b+c; } if (!p) { p = d*(0.3*1.5); } if ( !a || a &lt; Math.abs(c) ) { a = c; var s = p/4; } else { var s = p/(2*Math.PI) * Math.asin (c/a); } if (t &lt; 1) { return - 0.5*(a*Math.pow(2,10*(t-=1)) * Math.sin( (t*d-s)*(2*Math.PI)/p )) + b; } return a*Math.pow(2,-10*(t-=1)) * Math.sin( (t*d-s)*(2*Math.PI)/p )*0.5 + c + b; }, backIn: function(t, b, c, d, s){ //回退加速（回退渐入） if (typeof s == &apos;undefined&apos;) { s = 1.70158; } return c*(t/=d)*t*((s+1)*t - s) + b; }, backOut: function(t, b, c, d, s){ if (typeof s == &apos;undefined&apos;) { s = 3.70158; //回缩的距离 } return c*((t=t/d-1)*t*((s+1)*t + s) + 1) + b; }, backBoth: function(t, b, c, d, s){ if (typeof s == &apos;undefined&apos;) { s = 1.70158; } if ((t /= d/2 ) &lt; 1) { return c/2*(t*t*(((s*=(1.525))+1)*t - s)) + b; } return c/2*((t-=2)*t*(((s*=(1.525))+1)*t + s) + 2) + b; }, bounceIn: function(t, b, c, d){ //弹球减振（弹球渐出） return c - Tween[&apos;bounceOut&apos;](d-t, 0, c, d) + b; }, bounceOut: function(t, b, c, d){ if ((t/=d) &lt; (1/2.75)) { return c*(7.5625*t*t) + b; } else if (t &lt; (2/2.75)) { return c*(7.5625*(t-=(1.5/2.75))*t + 0.75) + b; } else if (t &lt; (2.5/2.75)) { return c*(7.5625*(t-=(2.25/2.75))*t + 0.9375) + b; } return c*(7.5625*(t-=(2.625/2.75))*t + 0.984375) + b; }, bounceBoth: function(t, b, c, d){ if (t &lt; d/2) { return Tween[&apos;bounceIn&apos;](t*2, 0, c, d) * 0.5 + b; } return Tween[&apos;bounceOut&apos;](t*2-d, 0, c, d) * 0.5 + c*0.5 + b; } } 时间版运动函数 原理：把值传入到Tween Json中运算，然后通过Tween返回的值，把元素运动到Tween返回值的位置。 //对象, {属性：属性值}, 要运动多少的时间, 运动方式, 回调函数 function timeMove(obj,json,times,fx,endFn){ var iCur = {}; for(var attr in json){ iCur[attr] = 0; if(attr == &apos;opacity&apos;){ iCur[attr] = Math.round(getStyle(obj,attr)*100); } else{ iCur[attr] = parseInt(getStyle(obj,attr)); } } var startTime = (new Date()).getTime(); //获取初始时间 clearInterval(obj.timer); obj.timer = setInterval(function(){ var changeTime = (new Date()).getTime(); //现在的时间 var t = times-Math.max(0,startTime - changeTime + times); //运动已经执行了多少时间 for(var attr in json){ var value = Tween[fx]( t, iCur[attr], json[attr]-iCur[attr], times); //代入计算公式 if(attr == &apos;opacity&apos;){ obj.style.opacity = value/100; obj.style.filter = &apos;alpha(opacity=&apos; + value + &apos;)&apos;; } else{ obj.style[attr] = value + &apos;px&apos;; } } if(t == times){ clearInterval(obj.timer); endFn &amp;&amp; endFn(); } },13) } function getStyle(obj,attr){ return obj.currentStyle?obj.currentStyle[attr] : getComputedStyle(obj)[attr]; }]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[面向对象编程]]></title>
      <url>%2F2017%2F03%2F23%2F%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%2F</url>
      <content type="text"><![CDATA[面向对象程序设计（Object-oriented porgramming,OOP)是一种程序设计范型，同时也是一种程序开发的方法，对象指的是类的实例。它将对象作为程序的基本单元，将程序和数据封装其中，以提高软件的重要性，灵活性和扩展性。 面向对象基础 包装对象： 基本类型都有自己对应的包装对象。 基本类型会找到对应的包装类型，然后包装对象把所有的属性和方法给了基本类型，然后包装对象消失。 系统对象： 我们把系统自带的对象，叫做系统对象。 &emsp;&emsp;&emsp;&emsp;&emsp; 1. 本地对象：String Number Boolean Object Function Array Date Error RegExp (非静态对象，需要实例化) &emsp;&emsp;&emsp;&emsp;&emsp; 2. 内置对象：Global Math (静态对象，不需要实例化) &emsp;&emsp;&emsp;&emsp;&emsp; 3. 宿主对象： DOM BOM (由浏览器提供的对象,随着运行的环境不同会有一定的变化) 面向对象： 1. 抽象：抓住核心问题 2. 封装：只能通过对象来访问方法 3. 继承：从已有对象上继承出新的对象 4. 多台：多对象的不同形态 对象的组成 ：方法（操作，行为）——对象下面的函数，叫做对象的方法 属性 : 对象下面的变量，我们叫做属性。 状态 : 静态的 关于new： 当new去调用一个函数，这个时候函数中的this就是创建出来的对象，而且函数的返回值直接就是this了（隐式返回）。 而new后面的函数，就叫做构造函数。 关于原型： 去改写对象下面公用的方法或者属性，让同样公用的方法或者属性在内存中只存在一份（提高性能）； prototype : 要写在构造函数的下面 Array.prototype.sum = function() { var result =0; for(var i=0; i&lt;this.length; i++){ result += this[i]; } return result; } var arr = [1,8,6,2,7]; alert(arr.sum()); 面向对象的写法： &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;function 构造函数() { &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp; 对象，属性 &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;} &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;构造函数.原型.方法 = function(){} 面向对象的使用：var 对象 = new 构造函数(); &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;对象.方法(); function CreatePerson(name){ this.name = name; //创建构造函数下面的属性 } CreatePerson.prototype.showName = function(){ alert(this.name); //创建原型下面的方法 } var obj = new CreatePerson(&apos;xiaoqiang&apos;); obj.showName(); //new一个新对象，调用原型方法 var obj2 = new CreatePerson(&apos;daxiang&apos;); obj2.showName(); //new一个新对象，调用原型方法 普通写法转面向对象写法： 先变形 尽量不要出现函数嵌套函数 可以有全局变量 把onload中不是赋值的语句放到单独函数中 var oParent = null; var aBtn = null; var aDiv = null; window.onload = function(){ oParent = document.getElementById(&apos;div1&apos;); aBtn = oParent.getElementsByTagName(&apos;input&apos;); aDiv = oParent.getElementsByTagName(&apos;div&apos;); init(); } function init(){ for(var i=0; i&lt;aBtn.length; i++){ aBtn[i].index = i; aBtn[i].onclick =change; } } function change (){ for(var i=0; i&lt;aBtn.length; i++){ aBtn[i].className = &apos;&apos;; aDiv[i].style.display = &apos;none&apos;; } this.className = &apos;active&apos;; aDiv[this.index].style.display = &apos;block&apos;; } 改成面向对象 全局变量就是属性 函数就是方法 Onload中创建对象 改this指向问题：在事件或定时器的时候容易出问题，尽量让面向对象的this指向对象 window.onload = function(){ var t1 = new Tab(&apos;div1&apos;); t1.init(); var t2 = new Tab(&apos;div2&apos;); t2.init(); } function Tab(id){ this.oParent = document.getElementById(id); this.aBtn = this.oParent.getElementsByTagName(&apos;input&apos;); this.aDiv = this.oParent.getElementsByTagName(&apos;div&apos;); } Tab.prototype.init = function(){ var This = this; for(var i=0; i&lt;this.aBtn.length; i++){ this.aBtn[i].index = i; this.aBtn[i].onclick =function(){ This.change(this); } } } Tab.prototype.change = function(obj){ for(var i=0; i&lt;this.aBtn.length; i++){ this.aBtn[i].className = &apos;&apos;; this.aDiv[i].style.display = &apos;none&apos;; } obj.className = &apos;active&apos;; this.aDiv[obj.index].style.display = &apos;block&apos;; } &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;div1&quot;&gt; &lt;input class=&quot;active&quot; type=&quot;button&quot; value=&quot;1&quot;&gt; &lt;input type=&quot;button&quot; value=&quot;2&quot;&gt; &lt;input type=&quot;button&quot; value=&quot;3&quot;&gt; &lt;div style=&quot;display: block&quot;&gt;111111&lt;/div&gt; &lt;div&gt;222222&lt;/div&gt; &lt;div&gt;333333&lt;/div&gt; &lt;/div&gt; &lt;div id=&quot;div2&quot;&gt; &lt;input class=&quot;active&quot; type=&quot;button&quot; value=&quot;1&quot;&gt; &lt;input type=&quot;button&quot; value=&quot;2&quot;&gt; &lt;input type=&quot;button&quot; value=&quot;3&quot;&gt; &lt;div style=&quot;display: block&quot;&gt;111111&lt;/div&gt; &lt;div&gt;222222&lt;/div&gt; &lt;div&gt;333333&lt;/div&gt; &lt;/div&gt; &lt;/body&gt; 面向对象之组件开发 原型链： 实例对象与原型之间的连接，叫做原型链 原型链的链接我们是看不见的，但是在Friebug下是可以查看到的，它的英文名字叫着 _proto_(隐式链接) 原型链的查找是由内而外的 原型链的最外层 : Object.prototype function Aaa(){ //this.num = 20; //优先弹出内部的属性 } //Aaa.prototype.num = 10; //其次是构造函数下面原型的属性 Object.prototype.num = 30; //最后弹出最外层Object的属性 var a1 = new Aaa(); alert(a1.num); 面向对象的属性和方法: hasOwnProperty() : 看是不是对象自身下面的属性 var arr = []; Arr.num = 10; Array.prototype.num2 = 20; alert(arr.hasOwnProperty(‘num’)); //true 证明num是arr对象下独有的属性 alert(arr.hasOwnProperty(‘num2’)); //flase 证明num2不是arr对象下独有的属性，所有的数组的原型下都有这个属性 constructor : 查看对象的构造函数 function Aaa(){} var a1 = new Aaa(); alert(a1.constructor); //function Aaa(){}; 弹出了a1下面的构造函数 同理，我们新建一个数组，查看它的构造函数是谁？ var arr = []; console.log(arr.constructor); // function Array() { [native code] } 弹出数组的构造函数 console.log(arr.constructor == Array); // true 可以运用这个属性来做判断 当我们写完一个函数的时候，不管是系统自带的函数，还是我们写的函数，都是一样的。 function Aaa(){} Aaa.prototype.constructor == Aaa; //每一个函数，程序会自动的帮我们生成这句话 var a1 = new Aaa(); alert(a1.constructor); //然后我们就可以通过constructor找到它的构造函数 function Aaa(){} function Aaa(){} Aaa.prototype.constructor == Array; //可以手动修改 var a1 = new Aaa(); alert(a1.constructor); //这个时候它的构造函数就会变成 function Array() { [native code] } instanceof : 运算符 对象与构造函数在原型链上是否有关系 &lt;可做类型基本类型判断&gt; function Aaa(){ } var a1 = new Aaa(); alert(a1 instanceof Aaa); // true 如果对象与构造函数是在同一个原型链上就会返回真 alert(a1 instanceof Array); //false 不在同一原型链上，弹出假 alert(a1 instanceof Object); //true 因为每个对象都是从他的最外层Object prototype对象，继承过来的 toString : Object上的方法 把对象转成字符串 系统对象下面都是自带的，而自己写的对象都是通过原型链prototype找Object下面的 var arr = []; alert(arr.toString == Object.prototype.toString); //false alert(typeof arr.toString); //string function Abb(){ } var a1 = new Abb(); alert(a1.toString == Object.prototype.toString); //true 通过toString我们可以在对象下写一些将对象转成字符串的方法 var num = 255; alert(num.toString(16)); //(16进制) ff toString括号里可以传入一个进制参数 利用toString做判断 var arr = []; alert(Object.prototype.toString.call(arr)); // object Array alert(Object.prototype.toString.call(arr) == &apos;[object Array]&apos;); //true 通过此方法可以做判断 var arr = {}; alert(Object.prototype.toString.call(arr)); // object Object var arr = new Date; alert(Object.prototype.toString.call(arr)); // object Date var arr = new RegExp; alert(Object.prototype.toString.call(arr)); // object RegExp 以上3种方法都可以做判断，但我们推荐使用toString方法。 测试：我们创建一个iframe，在这个iframe下面再创建一个数组，然后new一个实例，判断这个实例是不是数组。 var oF = document.createElement(&apos;iframe&apos;); document.body.appendChild(oF); var ifArray = window.frames[0].Array; var arr = new ifArray(); alert(arr.constructor == Array); //false alert(arr instanceof Array); //flase alert(Object.prototype.toString.call(arr) == &apos;[object Array]&apos;); //true 结论：通过以上方法的测试，最终只有toString判断的结论是正确的，不管我们在哪里创建的数组，它始终是个数组，所以他的结果只能为真。 继承： 什么是继承： 1. 在原有对象的基础上，略作修改，得到一个新的对象 (子类不影响父类，子类可以继承父类的一些功能，做到代码复用) 2. 不影响原有对象的功能 拷贝继承 : 如何添加继承 1. 属性：call 2. 方法：for in (拷贝继承) 步骤 先执行父级的构造函数，然后再添加子集的属性。 调用父级的构造函数。 通过原型链来继承父级的方法。 function Person (name,sex){ this.name = name; this.sex = sex; } Person.prototype.showName = function(){ alert(this.name); } Person.prototype.showSex = function(){ alert(this.sex); } var Person = new Person(&apos;tang&apos;,&apos;28&apos;); Person.showName(); 写一个新的子类，继承父类Person的属性和方法 function Worker (name,sex,job){ Person.call(this,name,sex); //调用父级的构造函数继承它的属性 //关于this——&gt;指向的是new出来的Worker对象 //关于call——&gt;call能改变this指向 //这种方法我们叫作构造函数伪装 this.job = job; } Worker.prototype = Person.prototype; //通过原型链来继承父级的方法--&gt;引用关系 Worker.prototype.showJob = function(){ alert(this.job); } var w1 = new Worker(&apos;tang&apos;,&apos;28&apos;,&apos;coder&apos;); w1.showName(); //弹出tang，因为Worker继承了父级Person的方法 w1.showJob(); //弹出 coder，Worker自有的方法 alert(Person.prototype.showJob); //弹出function(){ alert(this.job); } //Worker与Person属于引用关系，增加Worker原型下的方法同样会赋值给Person的原型 引用关系会将子类Worker的方法同样赋值给Person 我们并不希望，出现这类的引用关系，这个时候我们可以用for in循环将Person原型下的方法一个一个复制给Worker，这个时候Worker原型下的方法就不会影响到Person。 正确完美的版本 function Person (name,sex){ this.name = name; this.sex = sex; } Person.prototype.showName = function(){ alert(this.name); } Person.prototype.showSex = function(){ alert(this.sex); } function Worker (name,sex,job){ Person.call(this,name,sex); this.job = job; } for( var i in Person.prototype){ Worker.prototype[i] = Person.prototype[i]; } //将Worker.prototype = Person.prototype //替换成for in循环 Worker.prototype.showJob = function(){ alert(this.job); } var w1 = new Worker(&apos;tang&apos;,&apos;28&apos;,&apos;coder&apos;); w1.showName(); //tang w1.showJob(); //coder var P1 = new Person(&apos;daxia&apos;,&apos;28&apos;); P1.showName(); //daxia alert(Person.prototype.showJob); //undefined 通过以上代码，我们用了两个方法实现了子类的继承 用构造函数伪装，继承了父级的属性 用原型链继承了父级的方法 参考示例 拖拽继承 类似继承 : 什么是类似继承 利用构造函数(类)继承的方式 类： 1. JS中是没有类的这种概念，但是我们可以把构造函数看成是类。 2. 要做属性和方法继承的时候，要分开继承 示例代码1： function Aaa (){ this.name = &apos;tang&apos;; } Aaa.prototype.showName =function(){ alert(this.name); } function Bbb(){ } Bbb.prototype = new Aaa(); //因为Bbb的构造函数会被Aaa全部覆盖，又出现了引用关系 var b1 = new Bbb(); alert(b1.constructor); //所以弹出的是Aaa的构造函数function Aaa (){this.name = &apos;tang&apos;;} //Bbb指向有问题，所以要补充下面这句话 Bbb.prototype.constructor = Bbb; //重新将Bbb的构造函数指向Bbb alert(b1.constructor); //弹出的是Bbb的构造函数function Bbb (){} *代码1要做到类似继承依然不完善，我们会在 示例代码2 中说明问题 示例代码2 function Aaa (){ this.name = [1,2,3] //将Aaa的name等于数组 } Aaa.prototype.showName =function(){ alert(this.name); } function Bbb(){ } Bbb.prototype = new Aaa(); //因为Bbb的构造函数下面的属性和方法会被Aaa全部覆盖，原型链并不会指向Bbb Bbb.prototype.constructor = Bbb; //重新将Bbb的构造函数指向Bbb，但是属性还是引用关系，所以出现了下面的问题 var b1 = new Bbb(); b1.name.push(4); //b1在那么里push一个4 var b2 = new Bbb(); //新new一个b2 alert(b2.name); //b2弹出1,2,3,4。 这里就出问题了，b1.name.push之后，会影响到b2的name。 *通过代码2的证明，发现代码1 不符合面向对象继承的规则&lt;不影响原有对象的功能&gt; 我们通过代码3来修改 示例代码3 function Aaa (){ this.name = [1,2,3] //将Aaa的name等于数组 } Aaa.prototype.showName =function(){ alert(this.name); } //属性继承 function Bbb(){ Aaa.call(this); //依然需要用call来继承Aaa的属性 } //方法继承 方法一： var F = function(){}; //新声明一个F函数 F.prototype = Aaa.prototype; //将Aaa原型下面的方法赋值给F的原型，但是Aaa的属性不会赋值给F Bbb.prototype = new F(); //F下面没有属性，所以Bbb接受F的时候，是不会接受到它的属性，只会接受到它的方法，关于Bbb的属性我们在上面已经通过call来继承了Aaa的属性 方法二： Bbb.prototype = Object.create(Aaa.prototype); //通过Object.create也能实现 Bbb.prototype.constructor = Bbb; var b1 = new Bbb(); b1.name.push(4); //b1在那么里push一个4 var b2 = new Bbb(); //新new一个b2 alert(b2.name); //b2弹出1,2,3 不会再影响到父类和b1 代码3已经完美解决类似继承的问题 总结：真正的类似继承需要用到4句话， F的作用是用来作为方法的继承，而避免属性的继承。属性的继承还是需要用call来改变this指向继承， 原型继承 : 借助原型来实现对象继承对象 var a = { name : &apos;小明&apos; }; var b = cloneObj(a); b.name = &apos;小强&apos;; //b.name是重新赋值，不会影响到a alert( b.name ); //小强 alert( a.name ); //小明 function cloneObj(obj){ var F = function(){}; F.prototype = obj; return new F(); } 关于三大继承的总结 拷贝继承: 通用型的 有new或无new的时候都可以 类式继承: new构造函数 原型继承: 无new的对象 组件开发： 组件开发是什么 多组对象，像兄弟之间的关系 (代码复用的一种形式) 将配置参数、方法、事件，三者经行分离 组件开发中出现的问题 1. 当参数不写的时候会报错 解决办法：利用配置参数去替换默认参数的方法，如果配置参数没有，就走默认参数。 2. 当参数特别多的情况下，会出现参数顺序的问题 解决办法：利用json解决，把所有参数放在一个json里面 接下来用一个示例来说明 拖拽的在按下和抬起的时候title的变化，没有实际意义，只是用简单的理论方便我们理解 window.onload = function(){ var d1 = new Drag(); d1.go({ id : &apos;div1&apos; }); var d2 = new Drag(); d2.go({ id : &apos;div2&apos;, toDown : function(){ document.title = &apos;hello&apos;; } }); //给每个对象添加不同的配置参数 var d3 = new Drag(); d3.go({ id : &apos;div3&apos;, //给每个对象添加不同的配置参数 toDown : function(){ document.title = &apos;你好&apos;; }, toUp : function(){ document.title = &apos;世界&apos;;} }); var d4 = new Drag(); d4.go({ id : &apos;div4&apos;, toUp : function(){ document.title = &apos;拜拜&apos;; } }); //给每个对象添加不同的配置参数 } function Drag(){ this.oDiv = null; this.disX = 0; this.disY = 0; this.settings = { toDown : function(){}, //定义默认参数 toUp : function(){} } } Drag.prototype.go = function(opt){ var This = this; this.oDiv = document.getElementById(opt.id); for(var i in opt){ this.settings[i] = opt[i]; //用配置参数替换默认参数，如果配置参数没写，默认参数就不会被替换 } this.oDiv.onmousedown = function(ev){ var ev = ev || window.event; This.fnDown(ev); This.settings.toDown(); //执行默认参数，如果有配置参数，默认参数就会被替换 document.onmousemove = function(ev){ var ev = ev || window.event; This.fnMove(ev); }; document.onmouseup = function(){ This.fnUp(); This.settings.toUp(); //执行默认参数，如果有配置参数，默认参数就会被替换 }; return false; }; } Drag.prototype.fnDown = function(ev){ var This = this; this.disX = ev.clientX - this.oDiv.offsetLeft; this.disY = ev.clientY - this.oDiv.offsetTop; } Drag.prototype.fnMove = function(ev){ this.oDiv.style.left = ev.clientX - this.disX + &apos;px&apos;; this.oDiv.style.top = ev.clientY - this.disY + &apos;px&apos;; } Drag.prototype.fnUp = function(){ document.onmousemove = null; } 自定义事件 自定义事件：主要是跟函数有关系，就是让函数能够具备事件的某些特性 &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;有利于多人协作开发代码 拖拽自定义事件示例： &lt;script&gt; window.onload = function(){ var d1 = new Drag(); d1.go({ id : &apos;div1&apos; }); var d2 = new Drag(); d2.go({ id : &apos;div2&apos; }); bindEvent(d2,&apos;toDown&apos;,function(){ document.title = &apos;hello&apos;; }) //把函数存入一个json里面，在需要的地方调用 bindEvent(d2,&apos;toDown&apos;,function(){ document.body.style.background = &apos;green&apos;; }) bindEvent(d2,&apos;toUp&apos;,function(){ document.body.style.background = &apos;#fff&apos;; }) var d3 = new Drag(); d3.go({ id : &apos;div3&apos;,}); bindEvent(d3,&apos;toDown&apos;,function(){ document.title = &apos;你好&apos;; }); bindEvent(d3,&apos;toUp&apos;,function(){ document.title = &apos;世界&apos;; }); var d4 = new Drag(); d4.go({ id : &apos;div4&apos;}); bindEvent(d4,&apos;toUp&apos;,function(){ document.title = &apos;拜拜&apos;; }); } function Drag(){ this.oDiv = null; this.disX = 0; this.disY = 0; this.settings = {} } Drag.prototype.go = function(opt){ var This = this; this.oDiv = document.getElementById(opt.id); for(var i in opt){ this.settings[i] = opt[i]; //用配置参数替换默认参数，如果配置参数没写，默认参数就不会被替换(在这里它没用，这是组件开发用的，不是自定义事件用) } this.oDiv.onmousedown = function(ev){ var ev = ev || window.event; This.fnDown(ev); fireEvent(This,&apos;toDown&apos;); //把上面存入的toDown函数，放在这里调用 document.onmousemove = function(ev){ var ev = ev || window.event; This.fnMove(ev); }; document.onmouseup = function(){ This.fnUp(); fireEvent(This,&apos;toUp&apos;); //把上面存入的toUp函数，放在这里调用 }; return false; }; } Drag.prototype.fnDown = function(ev){ this.disX = ev.clientX - this.oDiv.offsetLeft; this.disY = ev.clientY - this.oDiv.offsetTop; alert(this.disX) } Drag.prototype.fnMove = function(ev){ this.oDiv.style.left = ev.clientX - this.disX + &apos;px&apos;; this.oDiv.style.top = ev.clientY - this.disY + &apos;px&apos;; } Drag.prototype.fnUp = function(){ document.onmousemove = null; } function bindEvent(obj,events,fn){ obj.listeners = obj.listeners || {}; obj.listeners[events] = obj.listeners[events] || []; obj.listeners[events].push(fn); if(obj.nodeType){ //判断DOM元素是否存在，如果存在就走里面，不存在就不走里面。因为d1,d2,d3,d4都不是DOM元素，只是一个new出来的对象 if(obj.addEventListener){ obj.addEventListener(events,fn,false); } else{ obj.attachEvent(&apos;on&apos;+events,fn); } } } function fireEvent(obj,events){ //主动触发自定义事件 //d1下面没有自定义函数，会直接报错。 //d2只有toDown，按下时不会报错，抬起的时候没有toUp，会报错。 //d3两个都有，所以会走里面 //d4只有toUp,按下的时候会报错 //所以需要判断DOM元素下的listener以及obj.listeners[events]是否存在。如果不存在就不执行里里面的函数 if(obj.listeners &amp;&amp; obj.listeners[events]){ for(var i=0; i&lt;obj.listeners[events].length; i++ ){ obj.listeners[events][i](); } } } &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;div1&quot;&gt;&lt;/div&gt; &lt;div id=&quot;div2&quot;&gt;&lt;/div&gt; &lt;div id=&quot;div3&quot;&gt;&lt;/div&gt; &lt;div id=&quot;div4&quot;&gt;&lt;/div&gt; &lt;/body&gt; 参考代码：基于 jQ的选项卡组件开发实例]]></content>
    </entry>

    
  
  
</search>
